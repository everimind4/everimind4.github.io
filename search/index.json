[{"content":"5. 함수 정의 def 함수명(인수 1, 인수 2, ...) : 명령 1 명령 2 . . . 명령 n return value 일부 요소들은 생략 가능하다.\n 인수가 없다면 생략할 수 있다. 반환값이 필요 없으면 return을 생략할 수 있다.  기본값 지정 특정 인수에 기본값을 지정해줄 수도 있다. 매개변수 선언 시 매개변수 = 기본값의 형태로 작성한다.\ndef plus(a = 0, b = 0) : return a + b 함수 호출 시 해당 매개변수의 입력을 생략하면 자동으로 기본값으로 설정된다.\n중요한 점은, 기본값을 갖는 매개변수들은 무조건 뒤쪽에 배치되어야 한다.\n뇌피셜 : 기본값이 지정된 매개변수가 중간에 선언된 경우, 실제 함수 호출 시 입력되는 값들이 어떤 매개변수에 전달되어야 하는지를 명확하게 알 수 없는 문제가 발생하기 때문이 아닐까?\n즉, ① def sum(a = 0, b)는 불가능하고, ② def sum(a, b = 0)은 가능하다. sum(4)를 실행하는 경우 ①번은 4라는 값이 a, b 중 어디에 전달되어야 하는지 명확하게 알 수 없기 때문이다.\n람다 함수 def 예약어를 사용한 함수 정의 외에도 간단하게 함수를 정의해서 사용하는 방법도 있다.\n\u0026gt;\u0026gt;\u0026gt; lambda 인수 1, 인수 2, ... : 반환값 이름이 없으므로 직접적인 호출이 불가능하다. 따라서 변수에 대입하고 C의 함수 포인터처럼 사용할 수 있다.\n\u0026gt;\u0026gt;\u0026gt; plus = lambda x, y : x + y \u0026gt;\u0026gt;\u0026gt; plus(4, 2) 6 하지만 이렇게 사용하면 그냥 def와 별다른 차이가 없으므로, lambda 함수는 인자로 \u0026lsquo;함수\u0026rsquo;를 입력받는 함수들에 일회용으로 사용되곤 한다.\nmap() map()함수는 리스트나 튜플의 전체 요소에 대해 특정한 처리를 하고 싶을 때 사용한다.\nmap(처리를 하는 함수, 처리 대상 리스트/튜플)의 방식으로 사용한다.\ndef와 lambda 2가지를 사용하여 리스트의 값을 제곱하는 예시를 살펴보자.\n\u0026gt;\u0026gt;\u0026gt; def square(x) : return x * x \u0026gt;\u0026gt;\u0026gt; list(map(square, [1, 2, 3])) [1, 4, 9] map()함수는 map 객체를 반환하므로 list()함수를 사용하여 형변환을 해 줌으로써 결과로서 리스트를 얻는다.\n다음은 lambda를 사용한 경우이다.\n\u0026gt;\u0026gt;\u0026gt; list(map(lambda x : x * x, [1, 2, 3])) [1, 4, 9] map() 함수 밖에서 사용하고자 하는 간단한 기능의 함수를 정의할 필요 없이, map() 함수 호출 시에 간단하게 원하는 기능을 함수로서 만들고자 할 때 lambda 함수를 사용할 수 있다.\n이처럼 lambda 함수를 사용해 인자로 함수를 입력받는 함수들의 종류는 매우 다양하다.\nfilter() 조건에 맞는 요소만 추출하는 함수이다.\n\u0026gt;\u0026gt;\u0026gt; list(filter(lambda a : a % 2 == 0, [0, 1, 2, 3, 4, 5])) [0, 2, 4] sorted() sorted()는 전달된 리스트를 직접 정렬하지 않고, 요소들이 정렬된 또 다른 리스트를 반환하는 함수이다.\nlabmda 함수를 인자로 전달해 key = lambda . . .형태로 정렬 기준을 지정해줄 수 있다.\n\u0026gt;\u0026gt;\u0026gt; sorted([\u0026#34;watermelon\u0026#34;, \u0026#34;mango\u0026#34;, \u0026#34;grapefruit\u0026#34;, \u0026#34;banana\u0026#34;]) [\u0026#39;banana\u0026#39;, \u0026#39;grapefruit\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;watermelon\u0026#39;] \u0026gt;\u0026gt;\u0026gt; sorted([\u0026#34;watermelon\u0026#34;, \u0026#34;mango\u0026#34;, \u0026#34;grapefruit\u0026#34;, \u0026#34;banana\u0026#34;], key = lambda x : len(x)) [\u0026#39;mango\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;watermelon\u0026#39;, \u0026#39;grapefruit\u0026#39;] 리스트 각 요소의 길이를 기준으로 정렬된 결과 리스트가 반환된 것을 볼 수 있다.\nreverse=True 인자를 입력하는 경우 정렬 순서를 반대로 설정할 수 있다.\n\u0026gt;\u0026gt;\u0026gt; sorted([\u0026#34;watermelon\u0026#34;, \u0026#34;mango\u0026#34;, \u0026#34;grapefruit\u0026#34;, \u0026#34;banana\u0026#34;], key = lambda x : len(x), reverse=True) [\u0026#39;watermelon\u0026#39;, \u0026#39;grapefruit\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;mango\u0026#39;] 튜플의 두 번째 요소를 기준으로 정렬하는 등의 활용도 가능하다.\n\u0026gt;\u0026gt;\u0026gt; sorted([(0, 4), (6, 2), (3, 1)]) [(0, 4), (3, 1), (6, 2)] // 0 → 3 → 6 \u0026gt;\u0026gt;\u0026gt; sorted([(0, 4), (6, 2), (3, 1)], key = lambda x : x[1]) [(3, 1), (6, 2), (0, 4)] // 1 → 2 → 4 리스트 내포 표기법 (List comprehension) 리스트에 저장할 요소의 규칙 등을 직관적으로 지정하여 리스트를 생성할 수 있다.\n[식 for 요소명 in 리스트]의 형태로 사용한다. 예시를 살펴보자.\n\u0026gt;\u0026gt;\u0026gt; [x * 2 for x in [1, 2, 3, 4]] [2, 4, 6, 8] \u0026gt;\u0026gt;\u0026gt; [x * x for x in range(5)] [0, 1, 4, 9, 16]  이를 활용해 간단하게 2차원 배열을 만들 수도 있다.  \u0026gt;\u0026gt;\u0026gt; [[x, x * 2, x * 3] for x in [1, 2, 3]] [[1, 2, 3], [2, 4, 6], [3, 6, 9]]  특정 값으로 초기화되는 다차원 리스트의 생성도 range()와 함께 활용하여 간단하게 해결할 수 있다.  \u0026gt;\u0026gt;\u0026gt; [[0 for x in range(3)] for y in range(4)] [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]  바로 위의 예시에서는 x와 y가 큰 의미가 없지만, 이를 살짝 변형하여 1씩 증가하는 값을 저장할 수도 있다.  y를 통해 만든 4칸의 리스트의 각 요소에 x를 통해 만든 3칸의 리스트를 각각 넣고 있다. 따라서 y 순번에 3을 곱한 후, x의 순번을 더해 0부터 11까지 값이 차례대로 증가하는 다차원 리스트를 만들 수 있다.\n\u0026gt;\u0026gt;\u0026gt; [[x + y * 3 for x in range(3)] for y in range(4)] [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]  이미 만들어진 2차원 배열에 접근하여 값을 변경하는 것도 가능하다.  \u0026gt;\u0026gt;\u0026gt; data = [[x + y * 3 for x in range(3)] for y in range(4)] [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]] \u0026gt;\u0026gt;\u0026gt; [[x * x for x in row] for row in data] [[0, 1, 4], [9, 16, 25], [36, 49, 64], [81, 100, 121]]  조건식을 추가하여 filter()처럼 사용할 수도 있다.  [식 for 요소명 in 리스트 if 조건식]의 형태로 사용한다. 조건을 충족한 요소에 대해서만 처음 식이 실행된다.\n\u0026gt;\u0026gt;\u0026gt; [x for x in [0, 1, 2, 3, 4, 5] if x % 2 == 0] [0, 2, 4] [0, 1, 2, 3, 4, 5] 중에서 x % 2 == 0을 충족시키는 값만 x를 통해 리스트에 저장되는 것을 볼 수 있다.\n6. 모듈 파이썬의 모듈은 C의 라이브러리와 같은 역할을 한다. 필요한 모든 함수나 자료구조를 전부 만들어 쓰는 것은 생산적이지 못하기 때문에, 기존에 정의된 모듈 혹은 사용자 정의 모듈을 가져와서(import) 사용할 수 있다.\n임포트(Import) 특정 모듈을 사용하려면 해당 모듈을 가져와야, 즉, 임포트(Import)해야 한다. 예를 들어, 난수를 생성하려면 random 모듈을 임포트(Import)해야 한다.\nimport random print(random.randint(0, 5)) 위 예시의 randint() 함수는 random 모듈을 임포트하지 않으면 사용할 수 없다.\n수많은 모듈과 각 모듈에 포함된 다양한 함수가 있지만, 이 단락에서 모두 소개하지 않겠고, 할 수도 없다. (그리고 뇌피셜이지만, 그때그때 필요하면 찾아보고 쓰는 게 코딩을 잘 하는 게 아닐까?)\n필요한 것만 임포트하기 전체 모듈을 임포트하는 대신, 해당 모듈에서 필요한 함수만 임포트할 수도 있다.\nfrom 모듈명 import 함수명의 형태로 임포트한다.\nfrom random import randint print(random.randint(0, 5)) 당연하겠지만 이 경우 randint()를 제외한 random 모듈 내의 다른 함수들은 사용이 불가능하다.\n__name__ 모듈은 누군가 작성한 파일을 내가 빌려 와서 사용하는 형태이다. 따라서 내가 작성한 파일도 모듈이 될 수 있다.\n__name__ 변수를 이용하면 어떤 파일이 실행될 때 내가 임포트를 했는지, 아니면 임포트를 당했는지를 알 수 있다.\n__name__ 변수는 다음 값을 갖는다.\n 프로그램이 시작된 파일에서는 __name__ 변수의 값이 __main__으로 설정된다. 모듈로서 임포트된 파일에서는 __name__변수의 값이 해당 모듈명으로 설정된다.  따라서 모듈로서 호출된 경우를 구분하기 위해 주로 다음과 같은 형식의 코드를 주로 사용한다.\nimport ... 초기화 코드 함수 및 클래스 정의, 전역 변수 선언 등 . . . if __name__ == \u0026#39;__main__\u0026#39; : . . . __name__변수에 저장된 값이 __main__인 경우 해당 파일에서 프로그램이 시작된 것이므로 특별한 기능을 수행하도록 설정할 수 있다.\n여기까지 함수와, 함수를 모아 둔 파일인 모듈을 살펴보았다.\n앞서 언급했든 모듈엔 수많은 종류가 있으므로, 추후 다른 내용을 학습하며 새로운 모듈이 나오면 그 때 해당 모듈에 포함된 함수들을 살펴보도록 하겠다.\n다음 글에서는 게임 개발에 필요한 PyGame 모듈에 대해 다뤄볼 예정이다.\n(다음 글에서 계속됩니다.)\n","date":"2021-04-26T00:00:00Z","image":"https://everimind4.github.io/p/%EC%A0%9C%EC%96%B4%EB%AC%B8-2/cover_hu0583afeab19a2de7dc49fcc1be6b44c7_761261_120x120_fill_box_smart1_2.png","permalink":"https://everimind4.github.io/p/%EC%A0%9C%EC%96%B4%EB%AC%B8-2/","title":"제어문 (2)"},{"content":"Virtualization (가상화) 가상화는 실제 대상을 가상의 대상으로 바꾸는 것을 의미한다.\n\r복숭아를 가상화해보자\r\n실제로 존재하는 복숭아(Physical peach)는 하나이다. 그런데 여러 사용자가 이를 원하는 경우, 복숭아를 가상화하여 가상의 복숭아(Virtual peach)를 여러 개 만들 수 있다. 그리고 이것들을 복숭아를 원하는 사람들에게 나눠준다.\n가상의 복숭아를 갖고 있는 사람들은 자기만 전용으로 사용하는 복숭아를 갖고 있다는 착각에 빠지는데, 그 이유는 다음과 같다.\n 자기가 가지고 있는 가상의 복숭아만 알 수 있다. 다른 사람들이 존재한다는 사실도 모른다. 따라서 다른 사람들의 가상의 복숭아를 알 수 없다. 심지어, 자신의 복숭아가 가상화되어 있다는 사실도 모른다.  이것이 운영체제가 수행하는 가상화의 기본 아이디어이다.\n그런데 실제 복숭아는 하나밖에 없는데, 어떻게 전용의 복숭아를 가지고 있다는 환상이 유지될까? 다른 사람이 쓰면 다른 누군가는 쓰지 못하지 않을까?\n결론부터 말하자면, \u0026ldquo;가상의 복숭아\u0026quot;라는 환상은 각 사람이 항상 복숭아를 사용하지 않기 때문에 유지될 수 있다.\n각 사람은 자신이 가지고 있는 가상의 복숭아를 잠깐 사용하지만, 나머지 대부분의 시간은 낮잠을 자기도 하고, 다른 일을 하기도 한다.\n운영체제는 중간에서 A라는 사람이 짧은 시간 동안 복숭아를 사용하고 나면 B에게 주고, B가 또 짧은 시간 동안 복숭아를 사용한 후에 C에게 복숭아를 주는 작업을 중간에서 수행한다.\n즉, 각 사람이 복숭아를 사용하지 않을 때는 다른 사람이 사용할 수 있도록 이리저리 옮겨 준다.\n물론 한 사람이 항상 복숭아를 사용하고 있다면 가상의 복숭아라는 환상이 깨지게 되겠지만, 실제로 각 사람이 복숭아를 필요로 하는 시간은 매우 짧기 때문에, 각 사람이 전용의 복숭아를 가지고 있다는 같은 환상을 잘 유지할 수 있다.\n이로부터 알 수 있는 가상화의 특징을 정리해보면 다음과 같다.\n 각 사람에게 가상의 복숭아를 나눠 준다. 각 사람은 매우 짧은 시간동안 복숭아를 사용하므로, 자신만의 전용 복숭아를 가지고 있다는 착각에 빠진다.  당연하겠지만 실제로는 복숭아 대신 CPU, Memory 등을 가상화해서 제공한다.\n먼저 CPU 가상화를 살펴볼텐데, CPU 가상화를 공부하려면 프로세스에 대해 알아야 한다.\nProcess (프로세스) 프로세스는 프로그램이 실행 중인 상태를 의미한다.\n\r운영체제와 외부 구조\r\n운영체제(Operating System)은 하드웨어 자원들을 관리하고, 프로세스들이 **시스템 콜(System call)**을 통해 하드웨어 자원을 요청하면 해당 자원을 가상화하여 프로세스에게 제공해 준다.\n프로세스 작동 과정(Running a Process) 프로세스는 다음 과정을 반복해서 수행한다.\n   Fetch Decode Execute Update     인스트럭션 가져오기 가져온 인스트럭션 해석 해석한 결과를 실행 새로운 인스트럭션 업데이트    여러 개의 프로세스를 작동시키고 싶으면 가장 간단하게 사용 가능한 방법은 프로세스마다 CPU를 할당하는 것이다.\n그러나 실행 가능한 프로세스의 수는 수백 가지인데, CPU의 갯수는 멀티코어 환경이라고 하더라도 2자릿수를 넘기기가 힘들다.\n따라서 그 다음으로 생각할 수 있는 방식은 프로세스 간의 **인터리빙(Interleaving, 교차)**이다.\n즉, 프로세스 A의 코드를 실행하다가 일정 시간이 지나면 잠시 멈춘 후 프로세스 B의 코드를 실행하고, 마찬가지로 일정 시간이 지나면 프로세스 C의 코드를 실행하는 것이다.\n인터리빙 방식의 문제는 프로세스 A의 코드에서 프로세스 B의 코드로 직접 이동해야 한다는 점이다. 즉, 전용의 CPU를 사용한다는 환상이 깨진다. 다른 프로세스에게 CPU를 직접 양보해야 하기 때문이다.\n운영체제도 일종의 프로그램이므로, 자신의 코드를 가지고 있다. 따라서 위와 같은 인터리빙 방식에서 운영체제를 거치도록 하여 인터리빙을 수행하면 가상화의 환상을 깨뜨리지 않고도 각 프로세스의 코드를 실행할 수 있다.\n\r왼쪽 : 직접 인터리빙 / 오른쪽 : OS 인터리빙\r\n왼쪽 방식에서는 프로세스 A가 프로세스 B에게 CPU를 직접 양보했다면, 오른쪽 방식에서는 실행 중인 프로세스 A로부터 CPU를 운영체제가 받아서 프로세스 B에게 전달함으로써 가상화를 유지할 수 있다.\n이렇게 CPU의 시간을 잘게 나누어서 각 프로세스에게 나눠 주는 방식을 Time Sharing이라고 하며, 현대 대부분의 운영체제들이 채택하고 있는 방식이다.\n프로세스란? 앞서 이야기했듯 프로세스는 실행 중인 프로그램을 의미한다.\n객체지향과 비교해서 생각하면 다음과 같은 비유가 가능하다.\n   Static Dynamic     클래스(Class) 인스턴스(Instance)   프로그램 프로세스    프로세스의 특징은 다음과 같다.\n Protection의 기본적인 단위이다. 프로세스 단위로 자원을 할당하고, 해당 자원에는 다른 프로세스가 간섭할 수 없다. PID(Process ID)를 통해 식별할 수 있다. 프로세스의 동적인 상태를 정의하는, 다음과 같은 정보들을 포함한다.  CPU context (Program counter, Stack pointer) OS resources (address space, open files, etc.) Other information (PID, state, owner, etc.)    프로세스의 실행 과정 (Process Creation)  프로그램 코드를 메모리에 로드한다.  메모리 내 프로세스별로 할당된 주소 공간에 로드한다. 메모리에 로드 시, 프로그램의 코드를 한번에 전부 로드하는 것이 아닌 필요한 부분만 그때그때 로드한다(Lazily Load) : 메모리 가상화의 Demand Paging 기법   프로그램을 실행하기 위한 런타임 스택을 할당한다.  스택에는 지역 변수, 함수의 매개변수, 반환 주소 등이 저장된다.   동적 할당을 위한 Heap 공간을 할당한다.  프로세스별로 동적인 공간 할당 요청이 있을 경우 Heap 공간에서 메모리를 할당한다. C에서는 malloc()을 사용해 메모리를 할당받고 free()를 사용해 할당을 해제한다.   OS에 의해 초기화 작업이 수행된다.  모든 프로그램은 기본적으로 3개의 오픈 파일 디스크립터를 만들어 준다.  표준 입력, 표준 출력, 표준 에러     CPU의 제어권이 OS로부터 새로 생성된 프로세스에게 넘어간다.  프로세스의 상태 (Process States) 프로세스는 다음 3가지 중 하나의 상태를 갖는다.\n  실행 중 (Running) : CPU를 할당받아 실행 중인 상태\n  대기 중 (Ready) : 실행될 준비는 끝냈지만 CPU를 할당받지 못한 상태\n  정지 (Blocked) : 모종의 이유로 실행이 잠시 중단된 상태\n 입출력과 같은 오래 걸리는 작업을 수행하는 경우 사용자 입력과 같은 이벤트를 기다리고 있는 경우  \r프로세스 간 상태 전이 관계도\r\n  프로세스는 기본적으로 Ready 상태와 Running 상태를 계속 오가며 실행된다.\n 프로세스가 처음 생성되면 Ready 상태가 된다. CPU를 할당받아 Running 상태가 된다. 정해진 할당 시간(Time slice)을 모두 사용하면 Ready 상태가 된다.    Running 상태에서 입출력(I/O) 혹은 사용자 Event를 기다려야 하는 경우 Blocked 상태가 된다.\n  Blocked 상태에서 필요한 작업을 다 처리하면 Ready 상태가 된다.\n 다시 Ready와 Running 두 상태의 전이를 반복한다.    Linux에서의 프로세스 리눅스 Shell에서 ps ax명령어를 입력하면 현재 실행 중인 프로세스 목록을 확인할 수 있다.\nPID, 프로세스의 현재 상태 등을 확인할 수 있다. 프로세스의 상태를 나타내는 기호에는 다음과 같은 것들이 있다.\n   기호 의미 상세     R Running or Runnable Running or Ready   S Sleeping    T Traced or Stopped Blocked   D Uninterruptible Sleep (주로) I/O   Z Zombie *중요    Zombie 상태는, 프로세스 자체는 종료되었지만 관련 데이터가 아직 삭제되지 않은 상태를 말한다.\n그밖에 위 기호와 함께 표기해 추가적인 정보를 나타내 주는 기호들도 있다.\n   기호 의미 상세     \u0026lt; High-priority task 높은 우선순위   N Low-priority task 낮은 우선순위   s Session leader Shell Program   + Foreground Process Group 포그라운드 프로세스   l Multi-threaded 멀티스레드 프로세스    프로세스 종료 프로세스는 다음과 같은 경우 종료된다.\n 자발적(Voluntary) 종료 : 의도된 종료  Normal exit : 프로그램이 끝까지 모두 실행된 상태 Error exit : 에러가 발생한 경우 코드 중간에 exit()를 사용해 종료   비자발적(Involuntary) 종료 : 의도되지 않은, 시스템에 의한 종료  Segmentation fault : 잘못된 메모리에 접근한 경우 Protection fault : 접근해서는 안 되는 자원에 접근한 경우 Exceed allocated resource : 할당된 자원을 초과해서 사용한 경우 Killed by another process : 커널에서 프로그램 실행 도중 ^C (Ctrl + C)를 입력하는 경우 등    또한 위에서도 언급했지만, 좀비 프로세스는 종료되고 난 후에도 관련 데이터가 삭제되지 않은 프로세스를 말한다.\n다음 글에서는 프로세스 관련 정보에 대해 알아본다.\n","date":"2021-04-17T00:00:00Z","permalink":"https://everimind4.github.io/p/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-1/","title":"프로세스 (1)"},{"content":"PCB (Process Control Block) 운영체제도 하나의 프로그램이므로, 다양한 정보를 저장하기 위한 자료구조들을 갖고 있다.\n그리고 프로세스 관리를 위해 프로세스 관련 정보들을 저장하고 있는 자료구조가 바로 PCB(Process Control Block)이다. 즉, 프로세스는 운영체제 내에서 프로세스의 정보들을 가지고 있는 자료구조로 표현될 수 있다. 따라서 PCB를 Process Descriptor라고 부르기도 한다.\nPCB는 프로세스에 관련된 모든 정보들을 모두 저장하고 있다.\n  CPU Register : 현재 프로세스가 CPU에서 돌아가고 있을 경우 현재 CPU의 상태는 Register의 값으로 정의될 수 있으므로 관련 값들을 저장\n  Process Information\n PID : Process ID PPID : Parent Process ID Process Group Priority : CPU 할당 우선순위 Process State : 프로세스 현재 상태 Signals    CPU 스케줄링 정보\n  메모리 관리 정보\n. . .\n  실제 리눅스에서는 task_struct라는 자료구조가 PCB의 역할을 한다. (Linux 3.2.0에서 3248 Byte)\nXV6 PCB UNIX V6를 ANSI C로 이식(Porting)한 교육용 운영체제 XV6에서는 Proc이라는 자료구조가 PCB의 역할을 한다.\nPCB의 구조를 살펴보기 전 관련된 몇 가지 자료구조를 살펴보자.\nContext context 구조체는 현재 프로세스의 register 정보를 저장하고 있다.\nstruct context { int eip;\t// Index pointer register  int esp;\t// Stack pointer register  int ebx;\t// Called the base register  int ecx;\t// Called the counter register  int edx;\t// Called the data register  int esi;\t// Source index register  int edi;\t// Destination index register  int ebp;\t// Stack base pointer register } 실행 중인 프로세스가 사용하는 레지스터의 값은 지속적으로 변하게 된다. 따라서 레지스터 값을 저장함으로써, 현재 프로세스의 상태를 스냅샷(Snapshot) 찍듯 저장할 수 있다.\ncontext 구조체는 다음과 같이 활용 가능하다.\n 특정 프로세스가 Running 상태에서 Ready 상태로 바뀔 때  현재 프로세스 상태를 context 구조체에 저장   해당 프로세스가 다시 Running 상태로 바뀔 때  context 구조체에 저장된 정보를 레지스터에 복사 기존에 실행하던 상태를 그대로 이어서 실행 가능    Process State procstate는 enumerator 타입으로, 프로세스의 현재 상태를 다음 6가지로 정의하고 있다.\nenum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }; Struct Proc 다음은 Proc 구조체의 코드이다.\nstruct proc { uint sz; // Size of process memory (bytes)  pde_t* pgdir; // Page table  char *kstack; // Bottom of kernel stack for this process  enum procstate state; // Process state  int pid; // Process ID  struct proc *parent; // Parent process  struct trapframe *tf; // Trap frame for current syscall  struct context *context; // swtch() here to run process  void *chan; // If non-zero, sleeping on chan  int killed; // If non-zero, have been killed  struct file *ofile[NOFILE]; // Open files  struct inode *cwd; // Current directory  char name[16]; // Process name (debugging)  }; 앞서 살펴본 context와 procstate외에도 pid, parent process, file 등 다양한 정보를 저장하기 위한 데이터가 포함되어 있는 것을 볼 수 있다.\nProcess State Queues 운영체제는 시스템의 원활한 작동을 위해 모든 프로세스의 상태를 추적할 필요가 있다. 이를 위해 사용하는 자료구조가 바로 프로세스 상태 큐(Process State Queue)이다.\n Ready Queue : 현재 Ready 상태인 프로세스들의 PCB를 저장하는 큐  Ready Queue에서 Process를 하나 선택하여 CPU를 할당해 준다.   Wait Queue : 특정 이벤트를 기다리는 프로세스들의 PCB를 저장하는 큐  시스템에 존재하는 모든 프로세스의 PCB들은 현재 상태에 따라 Ready Queue 또는 Wait Queue에 저장되어 있다. 각 프로세스의 상태가 변하게 되면, 저장된 Queue 또한 달라지게 된다.\nContext Switching CPU가 수행하는 프로세스가 바뀌는 현상이다. 이를 위해서는 다음과 같은 작업들을 수행해야 하므로 오버헤드가 발생한다.\n 기존에 실행하던 프로세스의 상태 정보를 저장하고 새로운 프로세스의 상태 정보를 복구한다. 메모리 캐시를 비우고(Flush) 다시 불러온다(Reload). 관련된 다양한 자료구조(테이블, 리스트, etc.)들을 업데이트한다.  이러한 오버헤드는 하드웨어에 따라 달라진다.\nContext Switch는 초당 100~1000회 정도 수행되므로, Context Switch 오버헤드는 성능에 매우 큰 영향을 미친다.\n다음은 Process A에서 Process B로 Context Switching이 발생하는 과정을 나타낸 것이다.\n\rContext Switching among Kernel, Hardware, Processes\r\n간단하게 설명하자면, 다음과 같은 과정을 거쳐 Context Switching이 일어난다.\n Process A가 실행 상태일 때, Timer Interrupt가 발생한다. 운영체제(Kernel)는 CPU를 Process A로부터 회수한다. switch() (Context Switching을 수행하는 routine)를 호출한다.  Process A의 레지스터 정보를 A의 PCB에 저장한다. Process B의 PCB로부터 Process B의 레지스터 정보를 복구한다.   하드웨어를 거쳐 Process B를 실행 상태로 변경한다.  Process 생성 유닉스 운영체제에서의 Process 생성은 fork()와 exec()라는 두 시스템 콜을 사용해 2단계로 이루어진다.\n fork() : 새로운 프로세스를 생성한다.  기존 프로세스를 복제(Clone)하여 새로운 프로세스를 생성한다. 원본 프로세스를 부모(Parent) 프로세스, 새로 생성된 프로세스를 자식(Child) 프로세스라고 한다. 모든 프로세스는 부모 프로세스를 갖는다. 부모 프로세스로부터 대부분의 정보를 상속받는다.  fork() 직후에는 PID를 제외하면 거의 모든 정보가 부모 프로세스와 동일하다.   부모 프로세스는 자녀 프로세스가 종료될 때까지 기다리거나, 혹은 자신이 원래 수행하던 코드로 바로 돌아갈 수도 있다.   exec() : fork() 후, 현재 프로세스 이미지를 새로운 프로그램을 로드해 덮어쓴다.  cf. Windows에서는 fork()와 exec()을 하나로 합친 CreateProcess()라는 API를 사용해 프로세스를 생성한다.\nfork()  새로운 PCB를 만들고 초기화한다. 새로운 Address Space를 만들고, 부모 프로세스의 Address Space를 복사하여 초기화한다. 그 밖의 부모 프로세스가 사용하던 정보들도 그대로 복사하여 초기화해 준다. 완성된 PCB를 Ready Queue에 저장한다. fork()는 2번 Return한다.  Return to Parent Process : pid of Child Process Return to Child Process : 0 Return Value를 보고 어떤 프로세스가 부모인지 구별할 수 있다.    다음 코드를 보자.\n// fork.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;int main() { int pid; if ((pid = fork()) == 0) // child  printf(\u0026#34;Child of %d is %d.\\n\u0026#34;, getppid(), getpid()); else // parent  printf(\u0026#34;I am %d. My child is %d.\\n\u0026#34;, getpid(), pid); } fork()를 수행하면 모든 정보가 복제되므로, 동일한 코드를 실행하는 프로세스가 2개가 된다.\n하지만 fork()의 Return Value에 따라 조건문의 어느 부분이 실행될 지가 결정된다. 실행 결과를 보자.\n$ gcc -o fork fork.c $ ./fork I am 35543. My child is 35544. Child of 35543 is 35544. $ ./fork I am 35545. My child is 35546 Child of 35545 is 35546 자식 프로세스와 부모 프로세스가 fork()의 Return Value에 따라 서로 다른 코드를 실행하는 것을 알 수 있다.\nexec()  현재 실행중인 프로세스를 중지한다. 새로운 프로그램을 Disk에서 읽어 와서 해당 프로세스의 Address Space를 덮어쓴다. 관련된 정보들을 업데이트해 준다. 완성된 PCB를 Ready Queue에 저장한다. exec()은 새로운 프로세스를 만들지 않는다.  기존의 프로세스를 새로운 프로그램의 프로세스로 덮어쓴다. 따라서 별도의 Return Value가 없다.    프로세스 계층 구조 (Process Hierarchy) fork() 의 작동 방식에 의해, 모든 프로세스는 부모-자식 관계를 갖게 된다.\n따라서 UNIX 시스템에서는 모든 프로세스를 Tree 구조로 정리할 수 있고, ps명령을 사용하여 전체 프로세스 리스트를 확인할 수 있다. (Linux도 동일하다.)\ncf. Windows는 별도의 Tree 구조를 가지고 있지 않고, 작업 관리자(Task Manager)를 통해 현재 시스템의 프로세스를 확인할 수 있다.\nSimplified Shell 다음은 간단한 형태의 Shell code이다.\nint main(void) { char cmdline[MAXLINE]; char *argv[MAXARGS]; pid_t pid; int status; while (getcmd(cmdline, sizeof(buf)) \u0026gt;= 0) { parsecmd(cmdline, argv); // Parse the command  if (!buildin_command(argv)) { if ((pid = fork()) == 0) { if (execv(argv[0], argv) \u0026lt; 0) { printf(\u0026#34;%s : command not found\\n\u0026#34;, argv[0]); exit(0); } } waitpid(pid, \u0026amp;status, 0); } } } 다음의 과정을 거쳐 작동한다.\n while : 루프를 돌며 사용자로부터 명령어를 입력받음 parsecmd : 입력받은 명령어를 파싱(Parsing) if (!builtin_command(argv)) : 입력받은 명령어가 Shell 자체 명령어인 Built-in Command인지 확인  만약 Built-in Command이면 그대로 실행한다.   그렇지 않은 경우 fork()를 수행하고, 자식 프로세스에서 새로 입력받은 명령어를 수행한다.  waitpid : 자식 프로세스의 실행이 종료될 때까지 대기한다.    운영체제 구현 모듈화 운영체제는 매우 거대한 프로그램이므로 전체를 한번에 다 구현하기가 어렵다. 따라서 각 부분을 작은 모듈로 나누어 구현한다.\n특정 부분의 수정이 필요한 경우 해당 모듈만 수정하면 되도록, 새로운 기능이 필요하면 새로운 모듈을 덧붙여서 구현 가능한 것이 모듈화의 장점이다.\nPolicy \u0026amp; Mechanism  Policy는 운영체제의 기능을 활용해 무엇을 할 것인지를 결정한다. Mechanism은 운영체제가 기능을 어떻게 수행할 것인지를 결정한다.  CPU를 예로 들어 살펴보면 다음과 같다.\n    Policy Mechanism (How to do?)     CPU 다음에 수행할 프로세스를 어떻게 결정할 것인가? 어떻게 동시에 여러 프로세스를 실행할 것인가?    Mechanism은 하나만 존재할 수 있지만, Policy는 여럿 존재할 수 있다.\n Policy와 Mechanism을 구분하는 것이 운영체제 설계의 핵심 원칙이다. Policies는 워크로드에 따라 얼마든지 달라질 수 있고, 누구나 자신이 원하는 방식을 새로 만들어 적용시킬 수 있다. Mechanism은 운영체제에서 동작하는 여러 Policies들이 공통적으로 사용하는 방식이다. Policy와 Mechanism을 구분함으로써 모듈화된 운영체제를 구현할 수 있고, 유지보수도 간편해진다.  앞으로 CPU와 메모리 가상화 등을 다루며 Mechanism과 Policy를 구분하여 살펴볼 것이다.\n다음 글에서는 CPU 가상화의 Mechanism인 Direct Execution에 대해 다룬다.\n","date":"2021-04-17T00:00:00Z","permalink":"https://everimind4.github.io/p/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-2/","title":"프로세스 (2)"},{"content":"운영체제의 기능 운영체제는 프로그램이 잘 실행되도록 돕는 프로그램이다. 따라서 다음과 같은 기능들을 갖는다.\n 프로그램을 실행하기 쉽도록 해 준다. 프로그램들이 메모리를 공유할 수 있도록 해 준다. 프로그램들이 외부 장치들과 정보를 주고받을 수 있도록 해 준다.  즉, 시스템이 올바르고 효율적으로 동작할 수 있도록 만드는 것이 OS의 역할이다.\n여기서 잠깐 프로그램이 무엇인가에 대해 간단하게 짚고 넘어가자.\n프로그램이란? 프로그램은 CPU가 수행하는 인스트럭션(Instruction, 명령어)들의 목록이라고 생각할 수 있다.\n즉, 프로그램을 실행한다는 것은 인스트럭션을 수행하는 것이다.\n따라서 프로그램이 실행될 때는 다음과 같은 과정을 거치게 된다.\n  Fetch : 메모리에서 인스트럭션을 하나 가져온다.\n  Decode : 가지고 온 인스트럭션이 어떤 종류인지를 알아낸다.\n  Execute : 인스트럭션을 실제로 수행한다.\n여기까지 완료하면 하나의 인스트럭션을 수행한 것이다.\n  다음 인스트럭션을 찾는다.\n  프로그램이 실행되고 종료되기까지 이 4개의 과정이 계속 반복된다.\n이러한 과정을 거쳐 프로그램이 실행되는 동안, 운영체제는 프로그램이 원활하게 실행될 수 있도록 환경을 제공하는 역할을 한다.\n운영체제의 기능과 역할은 크게 3가지이다.\n Virtualization (가상화) Concurrency (병행성) Persistency (지속성)  지금부터 각각의 개념에 대해 간단하게 살펴보도록 하자.\nVirtualization (가상화) 운영체제의 가장 중요한 역할 중 하나는 시스템을 가상화하여 프로그램에게 제공하는 것이다.\n구체적으로는 시스템의 물리적 자원(Physical Resource)인 하드웨어(Hardward)를 프로그램이 사용하기 편리하도록 가상화하여 제공하는 것을 의미한다.\n가상화된 형태는 프로그램이 사용하기 편리하다. 실제 하드웨어의 구조 및 복잡한 작동 방식, 하드웨어 공유 시 발생하는 문제 등을 신경쓰지 않아도 되기 때문이다.\n이러한 특징 때문에 운영체제를 Virtual Machine이라고 부르기도 한다.\nSystem call 시스템 자원은 가상화되어 있으므로, 프로그램들은 시스템 자원에 직접 접근할 수 없다. 따라서 프로그램들은 시스템 자원을 사용하려면 운영체제에게 요청해야 한다.\n운영체제에게 시스템 자원을 요청하기 위해 특수한 함수인 System call(시스템 콜)을 사용한다.\n운영체제는 프로그램들이 사용할 수 있는 다양한 시스템 콜을 제공한다.\nResource manager 운영체제는 CPU, Memory, Disk 등의 시스템 자원을 (가상화할 뿐만 아니라) 관리하는 역할을 한다.\n여러 프로그램들이 동시에 실행될 수 있도록 CPU를 공유하기도 하고, 각 프로그램이 사용할 수 있도록 메모리 및 디스크를 공유해 주기도 한다.\n즉, OS가 여러 프로그램들 사이에서 시스템 자원을 분배하는 중재자 역할을 한다.\nCPU 가상화 실행하고자 하는 프로그램의 개수에 비해 CPU의 개수는 너무나 적다.\n하지만 CPU가 단 하나만 존재하는 경우에도, CPU 가상화를 통해 여러 프로그램이 적은 수의 CPU를 동시에 사용할 수 있다.\nOS는 각 프로그램들에게 자신만의 전용 CPU를 가지고 있다는 환상을 제공해 준다. 즉, 하나의 프로세스로 여러 프로그램을 실행하더라도 각 프로그램들은 자신만의 CPU를 가지고 있는 것처럼 작동한다.\n메모리 가상화 CPU와 마찬가지로 실제 물리적인 메모리를 여러 프로그램이 사용할 수 있게 해 주는 것이 메모리 가상화이다.\n실제 메모리는 정보를 저장 가능한 바이트(Byte)들로 이루어진 저장 공간이다. 즉, **바이트의 배열(An array of Bytes)**로 생각할 수 있다. 각 바이트에는 고유한 번호가 존재하고, 이를 **주소(Address)**라고 한다. 이 주소를 가지고 메모리를 읽고 쓸 수 있다.\nOS는 각 프로그램들에게 자신만의 전용 메모리를 가지고 있다는 환상을 제공해 준다.\n하지만 각 프로그램에는 실제 주소(Physical Address)가 아닌 가상 주소(Virtual Address)가 제공된다.\n따라서 현재 실행 중인 프로그램들이 모두 동일한 주소에 접근하는 것 처럼 보이는 경우에도, 실제로는 다른 주소에 접근하게 된다.\nOS가 중간에서 가상 주소를 실제 주소로 연결해 주기 때문에, 이러한 경우에도 프로그램들은 문제 없이 작동할 수 있다.\nConcurrency (병행성) 병행성은 여러 프로그램들이 동시에 실행되어야 하기 때문에 발생하는 특징이다.\n다음 코드를 통해 병행성의 특징을 알 수 있다.\n// thread.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int counter = 0; int loops; void *worker(void *arg) { int i; for (i = 0; i \u0026lt; loops; i++) counter++; return NULL; } int main(int argc, char *argv[]) { . . . // Exception Handler  loops = atoi(argv[1]); printf(\u0026#34;Initial Value : %d\\n\u0026#34;, counter); pthread_t p1, p2; Pthread_create(\u0026amp;p1, NULL, worker, NULL); Pthread_create(\u0026amp;p2, NULL, worker, NULL); Pthread_join(p1, NULL); Pthread_join(p2, NULL); printf(\u0026#34;Final Value : %d\\n\u0026#34;, counter); return 0; } worker 함수는 전역 변수인 counter에 저장된 값을 1씩 증가시키는 함수이다.\nworker 함수를 main 함수 내에서 멀티스레드(Multi-thread)를 활용해 동시에 1000번씩 작동시킨다고 생각해 보자.\n$ gcc -o thread thread.c -Wall -pthread $ ./thread 1000 Initial Value : 0 Final Value : 2000 당연한 결과이다. 하지만 loops의 값이 커지게 되면 이상한 현상이 발생한다.\n$ ./thread 100000 Initial Value : 0 Final Value : 106296 $ ./thread 100000 Initial Value : 0 Final Value : 107258 예상대로라면 200000이 출력되어야 하지만, 그에 훨씬 못 미치는 값이 출력되는 것을 볼 수 있다. 더욱 심각한 것은, 조건 분기 등이 없음에도 매번 값이 다르게 출력된다는 사실이다. 이는 대표적인 병행성 문제이다.\n왜 이런 현상이 발생하는지는 내부 인스트럭션의 구조를 보면 알 수 있다. worker 함수는 최소 3개의 인스트럭션으로 이루어져 있다.\n Load : 메모리에서 counter 변수의 값을 읽는다. Increment : 해당 변수의 값을 1 증가시킨다. Store : 증가시킨 값을 다시 원래 위치에 저장한다.  문제는 두 스레드를 통해 실행되는 이 인스트럭션들이 서로 중첩되는 경우이다. 각 스레드의 인스트럭션들은 개별 스레드 내부에서는 순서대로 실행되지만, 멀티스레드의 경우 서로 끼어들 수 있다.\n   스레드 인스트럭션 수행하는 기능 counter     1 Load counter 변수를 불러온다 0   2 Load counter 변수를 불러온다 0   1 Increment 값을 1 증가시킨다 (0 → 1) 0   1 Store 증가시킨 값 1을 counter 변수에 저장한다 1   2 Increment 값을 1 증가시킨다 (0 → 1) 1   2 Store 증가시킨 값 1을 counter 변수에 저장한다 1    실제로 개별 스레드에서 한 번씩, 반복문이 총 2회 실행되었지만 내부 인스트럭션들이 중첩되는 바람에 의도와 다르게 실행되었음을 알 수 있다.\n이를 방지하기 위해서는 공유된 자원을 읽어와서 값을 증가시키고 저장하기까지의, 위에 나열한 최소 3개의 인스트럭션들이 한 묶음으로(Atomic) 실행되어야 한다.\nPersistency (지속성) 일반적으로 메인 메모리로 사용하는 DRAM은 휘발성(volatile) 저장 장치이다. 휘발성은 전원을 차단하면 저장된 정보가 삭제되는 특징을 말한다.\n따라서 데이터를 보존하기 위해 하드웨어나 소프트웨어의 도움을 받는다.\n 하드웨어(Hardware) : 입출력 장치인 하드 디스크 드라이브(HDD), 솔리드-스테이트 드라이브(SDD) 소프트웨어(Software) : 운영체제의 파일 시스템(File System)  운영체제는 시스템에 연결된 HDD나 SSD와 같은 저장 공간을 추상화하여 제공하며, 저장된 파일을 관리하는 **파일 시스템(File System)**을 갖고 있다.\n프로그램이 파일을 열거나 수정해 저장하는 등의 파일 관련 작업을 수행하려면 시스템 콜을 요청해야 한다.\n지속성(Persistency)은 디렉토리와 파일로 추상화된 공간을 통해 데이터를 보존하는 것을 말한다.\n운영체제가 갖는 지속성(Persistency)의 특징은 다음과 같다.\n 프로그램의 요청을 받아 어느 위치에 있는 파일을 수정하거나 새로운 파일을 작성할 지를 결정한다. 파일시스템은 파일 작성 중 오류가 발생한 경우 Journaling이나 Copy-on-Write등의 방식을 사용해 오류를 복구한다.  운영체제 설계 목표  Abstraction : 추상화 및 가상화를 통해 사용 편의성을 더한다. High Performance : 성능이 뛰어나야 한다.좋아야 한다. 하드웨어에 OS가 설치된 후 그 위에 다른 모든 프로그램들이 설치되기 때문에, OS의 성능이 비효율적인 경우 다른 모든 프로그램들의 성능이 저하된다. Protection (Isolation) : 프로그램 간의 간섭을 방지해야 한다. 특정 프로그램이 다른 프로그램의 데이터를 훼손하거나 덮어쓰는 경우를 막을 수 있어야 한다. Reliability : OS는 항상 작동해야 한다. OS가 작동을 멈추면 전체 프로그램들도 작동할 수 없게 되고, 컴퓨터를 사용할 수 없게 된다. Others : Energy-efficiency, Security, Mobility, . . .  앞으로 운영체제의 3요소인 Virtualization, Concurrency, Persistency에 관한 내용을 주제별로 다룰 예정이다.\n","date":"2021-04-16T00:00:00Z","permalink":"https://everimind4.github.io/p/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%9C%EC%9A%94/","title":"운영체제 개요"},{"content":"1. 들여쓰기(Indentation)  C에서는 코드 실행 단위인 블록을 구분하기 위해 중괄호{ }를 사용하고, 들여쓰기는 가독성을 증진시키는 데만 사용되는 개념이었다.\n하지만 파이썬에서는 들여쓰기 수준으로 코드 블록을 구분한다.\n C/C++ Style if (조건문) { 명령1; 명령2; } Python Style if a \u0026gt; b: 명령1 명령2 C와 비교했을 때, Python의 문법적 차이는 다음와 같다.\n 조건문을 괄호( )로 싸지 않고 콜론:을 조건문 뒤에 적는 것으로 간단하게 사용한다. 명령문의 끝에 세미콜론;을 적지 않는다. (적어도 상관은 없음) 코드 블록을 감싸는 중괄호{ }를 생략한다. 대신 들여쓰기(Indentation)로 코드 블록을 구분한다.  그리고 마지막 항목인 중괄호 생략이 바로 파이썬의 가장 큰 특징이다. 자세한 내용은 조건식에서 추가적으로 다룬다.\n2. 조건식 조건식으로 입력되는 부울값에 따라 제어문에 의해 실행되는 코드가 달라진다(코드의 흐름이 달라진다).\n비교연산자 두 개의 값을 비교하고 부울값을 반환한다.\n   연산자 반환값     A == B 두 값이 서로 같으면 True, 아니면 False   A != B 두 값이 서로 다르면 True, 아니면 False   A \u0026lt; B A가 B보다 작으면 True, 아니면 False   A \u0026lt;= B A가 B보다 작거나 같으면 True, 아니면 False   A \u0026gt; B A가 B보다 크면 True, 아니면 False   A \u0026gt;= B A가 B보다 크거나 같으면 True, 아니면 False   A in B A가 B(리스트 or 튜플)에 포함된(B의 요소 중 A가 존재) 경우 True, 아니면 False    부울연산자 부울연산자의 피연산자로 비교연산자 등의 조건식을 조합하여 사용할 수 있다.\n   A B AND OR     True True True True   True False False True   False True False True   False False False False    not은 입력값과 반대되는 부울값을 반환한다. 이를 정리하면 다음과 같다.\n   연산자 반환값     조건식1 and 조건식2 조건 1과 조건 2가 모두 True이면 True, 아니면 False   조건식1 and 조건식2 조건 1과 조건 2중 하나만 True여도 True, 아니면 False   not 조건식 조건식이 True이면 False, False이면 True 반대되는 부울값을 반환한다.    부울 이외의 데이터형 위 2개 연산자의 경우 부울값을 반환하므로 조건식으로 사용할 수 있지만, 부울값 이외의 값도 조건식으로 사용할 수 있다. 그대로 사용하는 것은 아니고, 부울값으로 데이터형을 변환한 후 조건식으로 사용한다.\n   데이터형 True False     수치 0(0.0) 0 이외의 값   문자열 빈 문자열 '', \u0026quot;\u0026quot; 비어있지 않은 문자열   리스트, 튜플 비어있는 리스트[ ], 튜플( ) 요소가 하나라도 있는 경우    bool() 함수를 사용해 변환 결과를 알아볼 수 있다.\n\u0026gt;\u0026gt;\u0026gt; bool(0) False \u0026gt;\u0026gt;\u0026gt; bool(0.0) False \u0026gt;\u0026gt;\u0026gt; bool(426) True \u0026gt;\u0026gt;\u0026gt; bool(2.718) True \u0026gt;\u0026gt;\u0026gt; bool({}) False \u0026gt;\u0026gt;\u0026gt; bool((1, 2, 3)) True \u0026gt;\u0026gt;\u0026gt; bool(\u0026#34;Hello, Python!\u0026#34;) True \u0026gt;\u0026gt;\u0026gt; bool(\u0026#39;\u0026#39;) False 3. 조건문  코드 블록을 콜론:과 들여쓰기만으로 구분한다는 점을 제외하면 C와 거의 동일하다.\n들여쓰기로 코드 블록을 구분하는 것을 구체적으로 살펴보기 위해 각 경우의 코드 예시를 살펴본다.\n if: ~ else: 조건문이 True일 경우 if 바로 뒤 블록 내의 코드를 실행하고, False일 경우 else 뒤 블록의 코드를 실행한다.\n\u0026gt;\u0026gt;\u0026gt; a = 4 \u0026gt;\u0026gt;\u0026gt; b = 2 \u0026gt;\u0026gt;\u0026gt; if a \u0026gt; b: print(a + b) else: print(a - b) 6 \u0026gt;\u0026gt;\u0026gt; if a \u0026lt; b: print(a + b) else: print(a - b) 2 동일한 if문을 실행했음에도 조건식의 값에 따라 다른 결과가 나타나는 것을 볼 수 있다.\nif: 단독 사용 False인 경우를 고려할 필요가 없는 경우 if문을 단독으로 사용한다.\n\u0026gt;\u0026gt;\u0026gt; subject = {\u0026#34;Korean\u0026#34;, \u0026#34;Math\u0026#34;, \u0026#34;English\u0026#34;} \u0026gt;\u0026gt;\u0026gt; score = {} \u0026gt;\u0026gt;\u0026gt; if subject: print(subject) {\u0026#39;Korean\u0026#39;, \u0026#39;Math\u0026#39;, \u0026#39;English\u0026#39;} \u0026gt;\u0026gt;\u0026gt; if score: print(score) \u0026gt;\u0026gt;\u0026gt; subject 리스트에는 요소가 존재하므로 해당요사가 출력되고, score리스트에는 요소가 없으므로 아무런 일도 일어나지 않는다.\nif: elif: else elif는 else if를 줄인 형태이다. 사용법은 C와 동일하므로 추가로 예시를 살펴보지는 않는다.\n4. 반복문  파이썬의 반복문은 C와 동일하게 while과 for가 있다.\n while while (조건문): 명령1 명령2 명령3 이런 형태의 코드의 경우 조건문이 True에서 False가 되기 전까지 명령1, 명령2를 반복해서 수행하다 while루프가 종료되면 명령3을 실행하게 된다.\nfor  python의 for문은 C에 비해 매우 직관적이다.\n for문의 기본적인 구조는 다음과 같다.\nfor (변수) in (리스트, 튜플, 문자열 등): 명령1 명령2 . . . 즉, in뒤의 데이터형에서 요소를 하나씩 꺼내어(문자열의 경우 문자를 하나씩) 변수에 넣고, 명령을 처리한다.\n이렇게 특정 요소에 차례대로 접근 가능한 대상을 이터러블(Iterable) 객체라고 부른다.\n복잡한 응용도 가능하다. 변수 위치에 꼭 단일 변수만 와야 하는 것은 아니고, 특정 자료형도 위치할 수 있다.\nfor (a, b) in [(1, 2), (3, 4), (5, 6)]: print(a) print(b) print(\u0026#34;next\u0026#34;) 1 2 next 3 4 next 5 6 next 오른쪽 2차원 리스트의 각 요소인 튜플이 자동으로 왼쪽 튜플의 요소에 언팩되어 들어간다.\nfor ~ range() 기존의 C에서처럼 숫자를 증가시키는 반복문 형태도 있다. range()함수와 함께 사용한다. range() 함수는 번호가 들어 있는 이터러블 객체를 반환하는 함수이다.\nrange(숫자)는 0에서부터 (해당 숫자-1)까지의 정수들을 요소로 하는 리스트(튜플)처럼 사용할 수 있다.\nrange()의 인수는 1개부터 3개까지 입력 가능한데, 각각 다음 의미를 갖는다.\n   인수의 개수 1번째 인수 2번째 인수 3번째 인수     1개 입력 마지막 숫자 X X   2개 입력 시작 숫자 마지막 숫자 X   3개 입력 시작 숫자 마지막 숫자 증가폭    인수를 1개만 입력하는 경우 0부터 시작하는 것으로 인식한다.\n\u0026gt;\u0026gt;\u0026gt; print(range(4)) range(0, 4) 각 경우를 직접 출력해보면 다음과 같은 결과를 볼 수 있다.\n\u0026gt;\u0026gt;\u0026gt; for i in range(4): print(i) 0 1 2 3 \u0026gt;\u0026gt;\u0026gt; for j in range(2, 6): print(j) 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; for k in range(5, 15, 3): print(k) 5 8 11 14 break, continue  C에서와 동일하게 사용할 수 있다.\n  break : 반복 도중 반복문을 강제로 벗어난다. continue : 반복 도중 반복문의 맨 앞으로 돌아간다.  C와 차이가 없으므로 구체적인 설명은 생략한다.\n다음 글에서는 파이썬에서 함수를 정의하는 방법과, 기존에 정의된 함수 모음인 모듈에 대해 다룰 예정이다.\n(다음 글에서 계속됩니다.)\n","date":"2021-04-05T00:00:00Z","image":"https://everimind4.github.io/p/%EC%A0%9C%EC%96%B4%EB%AC%B8-1/cover_hu0583afeab19a2de7dc49fcc1be6b44c7_761261_120x120_fill_box_smart1_2.png","permalink":"https://everimind4.github.io/p/%EC%A0%9C%EC%96%B4%EB%AC%B8-1/","title":"제어문 (1)"},{"content":"7. 관련 함수들 len 리스트나 튜플 내의 요소 개수를 반환하는 함수이다.\n\u0026gt;\u0026gt;\u0026gt; len([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]) 4 \u0026gt;\u0026gt;\u0026gt; len([2, 3, 5, 7, 11, 13]) 6 대상 요소가 무엇이든 전체 개수만 반환하므로, 2차원 이상의 리스트 혹은 튜플의 경우에는 다음과 같은 결과를 확인할 수 있다.\n\u0026gt;\u0026gt;\u0026gt; fibonacci = [[1, 1, 2, 3, 5, 8], [13, 21, 34, 55, 89], [144, 233, 377, 610, 987]] \u0026gt;\u0026gt;\u0026gt; len(fibonacci) 3 \u0026gt;\u0026gt;\u0026gt; len(fibonacci[2]) 5 copy 리스트를 복제하는 (리스트) 메소드이다.\n C에서는 Shallow copy(얕은 복사)와 Deep copy(깊은 복사)를 구별한다. C에서는 특히 Dangling pointer의 발생을 방지하려면 이 둘의 차이에 대해 잘 이해해야 하는데, 파이썬에도 이 둘의 차이를 구분한다.\n 그냥 대입하는 방식으로 리스트를 복사하면 얕은 복사가 일어난다. 다음 코드를 보면 문제가 있음을 알 수 있다.\n\u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; b = a \u0026gt;\u0026gt;\u0026gt; a[2] = 9 \u0026gt;\u0026gt;\u0026gt; a [1, 2, 9] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 9] 같은 리스트를 참조하기 때문에 이와 같은 문제가 발생한다. C에서는 직접 또다른 메모리 공간을 할당받는 등의 방법을 사용하지만, 파이썬에서는 copy 함수로 이와 같은 문제를 해결한다.\n\u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; b = a.copy() \u0026gt;\u0026gt;\u0026gt; a[2] = 9 \u0026gt;\u0026gt;\u0026gt; a [1, 2, 9] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3] 이를 통해 copy 메소드는 서로 다른 리스트를 참조하도록 만들 수 있고, 얕은 복사가 아닌 깊은 복사가 수행 가능함을 알 수 있다.\n리스트를 복제하고 싶을 때 copy 메소드를 사용할 수 있다.\n단, 튜플은 값을 변경할 수 없으므로 copy 메소드를 사용할 수 없다.\nin 어떠한 값이 리스트나 퓨틀 내에 존재하는지 확인하기 위한 함수이다.\n\u0026gt;\u0026gt;\u0026gt; subjects = (\u0026#34;Korean\u0026#34;, \u0026#34;English\u0026#34;, \u0026#34;Math\u0026#34;, \u0026#34;Science\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#34;Math\u0026#34; in subjects True \u0026gt;\u0026gt;\u0026gt; \u0026#34;Music\u0026#34; in subjects False 알고 싶은 값 in 리스트(or 튜플) 의 형태로 사용한다. 값이 포함되어 있으면 True, 그렇지 않으면 False가 반환된다.\nindex in함수는 단순히 포함 여부를 확인할 수 있다면, index 메소드는 요소의 위치를 알려 준다.\n\u0026gt;\u0026gt;\u0026gt; weekdays = (\u0026#34;Mon\u0026#34;, \u0026#34;Tue\u0026#34;, \u0026#34;Wed\u0026#34;, \u0026#34;Thu\u0026#34;, \u0026#34;Fri\u0026#34;, \u0026#34;Sat\u0026#34;, \u0026#34;Sun\u0026#34;) \u0026gt;\u0026gt;\u0026gt; weekdays.index(\u0026#34;Tue\u0026#34;) 1 \u0026gt;\u0026gt;\u0026gt; weekdays.index(\u0026#34;Fri\u0026#34;) 4 요소를 찾을 수 없는 경우에는 에러가 발생한다.\nsort vs sorted   sorted\nsorted는 함수이다. 인수로 주어진 리스트나 튜플을 정렬한 후 복사본을 반환한다.\n원래 리스트의 요소 순서는 변하지 않는다.\n  sort\nsort는 (리스트) 메소드이다. 해당 리스트를 정렬하고, 반환 값은 없다.\n즉, 해당 리스트의 요소들이 실제로 순서가 바뀌어 정렬된다.\n  print print는 인수로 주어진 정보를 콘솔에 출력하는 함수이다.\n콘솔 출력 함수인 print는 튜플( )과 조합하여 다양한 방식으로 사용할 수 있다.\n  % 연산자\n C에서는 printf() 함수 내에 1번째 매개변수로 형식지정자(ex. 정수 %d, 문자 %c, 실수 %f)를 포함하는 문자열을 넣고, 2번째 매개변수로 각 형식지정자에 해당하는 변수를 ,로 구분하여 입력한다.\n 파이썬에서는 문자열 내에 %s(문자열 형식), %d(정수형) 등의 서식을 삽입하고, 해당 문자열 뒤에 % 연산자, 그리고 그 뒤에 튜플 형식으로 출력할 데이터를 배치한다.\n문자열 지정 형식은 C와 거의 동일하다.\n   문자열 10진수 16진수 부동소수     %s %d %x %f    \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;제 이름은 %s입니다. 저는 %dcm입니다.\u0026#34; % (\u0026#34;홍길동\u0026#34;, 185)) \u0026#34;제 이름은 홍길동입니다. 저는 185cm입니다.\u0026#34; 당연하지만 사전에 튜플을 선언하고 사용할 수도 있다. (오히려 이 경우가 좀 더 일반적인 것 같다.)\n\u0026gt;\u0026gt;\u0026gt; score = (96, 88) \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;수학 : %d점, 영어 : %d점\u0026#34; % score) \u0026#34;수학 : 96점, 영어 : 88점\u0026#34; 지정 형식과 다른 데이터형을 입력하는 경우 에러가 발생하므로 형식 지정 및 값 입력 시에 주의를 요한다.\n  .format() 메소드\n% 연산자를 사용하는 방식과 비교하면 기본적으로 2가지 차이가 있다.\n  데이터를 삽입하고 싶은 곳에 %d등의 형식 대신 { }을 사용\n  print에 인수(매개변수)로 전달하는 대신 해당 자료형의 메소드 형태로 호출\n  % 연산자와 비교하면 다음과 같다.\n\u0026gt;\u0026gt;\u0026gt; score = (96, 88) \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;수학 : {}점, 영어 : {}점\u0026#34;.format(score[0], score[1])) \u0026#34;수학 : 96점, 영어 : 88점\u0026#34; 그러나 { }내에 번호를 지정하거나 이름을 붙이는 방식으로도 사용할 수 있다!\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#34;수학 : {1}점, 영어 : {0}점\u0026#34;.format(96, 88)) \u0026#34;수학 : 88점, 영어 : 96점\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;수학 : {수학}점, 영어 : {영어}점\u0026#34;.format(수학 = 96, 영어 = 88)) \u0026#34;수학 : 96점, 영어 : 88점\u0026#34; 이 밖에도 C에서와 유사하게 서식 문자열을 사용해 자릿수 지정, 좌/우 정렬, 패딩을 주는 등의 다양한 서식 지정 등이 가능하다(고 한다).\n  8. 주석(Comment) 다른 수많은 언어에서도 사용되는 개념으로, 간단하게 말하면 프로그램에 관한 개발자의 메모이다.\npython에서는 기본적으로 1행짜리 주석만 지원한다.\n# 이 행은 주석입니다. # 이 행도 주석입니다. 그러나 여러 행에 걸친 문자열 ''' ''' 또는 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;기호를 개행과 함께 사용해 여러 행 주석을 작성할 수도 있다.\n\u0026#34;\u0026#34;\u0026#34; 여기부터 주석으로 볼 수 있습니다. 이 행도 주석이라고 볼 수 있고, 원한다면 계속 주석을 작성할 수 있습니다. \u0026#34;\u0026#34;\u0026#34; 그러나 이는 여러 행에 걸쳐 문자열을 작성하는 방법으로, 정석적인 사용 방식은 아니다.\n9. 줄바꿈 코드를 작성하다보면 필요 이상으로 길어질 수도 있다.\n이러한 경우 백슬래시 \\를 사용해 코드를 여러 줄에 걸쳐 작성 가능하다.\nthis_is_test_variable = test \u0026lt; 0 or \\ real \u0026gt; 0 or \\ just_test == 1 리스트나 튜플, 딕셔너리의 요소를 구분하기 위한 개행은 백슬래시를 삽입하지 않아도 된다.\nweekdays = (\u0026#34;Mon\u0026#34;, \u0026#34;Tue\u0026#34;, \u0026#34;Wed\u0026#34;, \u0026#34;Thu\u0026#34;, \u0026#34;Fri\u0026#34;, \u0026#34;Sat\u0026#34;, \u0026#34;Sun\u0026#34;) 여기까지 데이터형과 데이터 구조를 정리해보았다.\n다음 챕터에서는 프로그래밍 언어의 꽃~~(개인적인 생각입니다)~~인 제어문에 대해 정리할 예정이다.\n(다음 글에서 계속됩니다.)\n","date":"2021-03-29T00:00:00Z","image":"https://everimind4.github.io/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-3/cover_hu0583afeab19a2de7dc49fcc1be6b44c7_761261_120x120_fill_box_smart1_2.png","permalink":"https://everimind4.github.io/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-3/","title":"데이터형과 데이터 구조 (3)"},{"content":"4. 데이터형 파이썬의 기본적인 데이터형은 다음과 같다.\n   종류 예약어 상세 예시     정수 int 소수점이 없음 4, 2, 6   실수 float 소수점이 있음 3.14, 2.71   문자열(String) str 문자열의 나열 'everimind4'   부울(Boolean) bool 논리값을 저장 True, False    1. 숫자 숫자를 저장하기 위한 변수는 다른 언어들과 마찬가지로 2종류가 있다.\n 정수형 : 정수 값을 저장, 소수점이 없다. 실수형 : 실수 값을 저장, 소수점이 있고, 부동소수형이라고도 한다.   C와의 차이점 : 예약어로 변수의 데이터형을 지정할 필요 없이 그냥 값을 저장하면 자동으로 지정된다.\n 그리고 다음과 같은 규칙이 있다.\n  같은 데이터형끼리 계산하면 기본적으로 같은 데이터형이 된다.\n  정수끼리 나눗셈을 하면 실수형이 된다.\n  정수와 실수형을 서로 계산하면 결과는 실수형이 된다.\n  2. 문자열  C와의 차이점 : 문자(char)형 변수는 없고 문자열(string)만 있다.\n 문자열은 ' ' 또는 \u0026quot; \u0026quot;로 감싸서 만든다.\n그 이유는, '나 \u0026quot;가 포함된 문자열을 저장하기 위해서이다.\n C에서는 \\' 또는 \\\u0026quot;와 같이 해당 기호 앞에 백슬래시(\\)를 적어 주는 방식으로 정규표현식을 사용해 이와 같은 문제를 해결하였다.\n Hi, my name is \u0026quot;Alan Choi\u0026quot;.\n위 문장을 저장하려면 어떻게 해야 할까? \u0026quot; \u0026quot;를 사용하면 is 까지만 저장하라는 의미가 되어 버릴 것이다. 이런 경우를 방지하기 위해 ' '와 \u0026quot; \u0026quot;의 2가지 형태를 지원한다.\n5. 형변환 데이터형은 서로 형변환이 가능하다.\n특정한 경우 변환 시 에러가 발생하는 것을 제외하면, 기본적으로 모든 자료형 간의 상호 변환이 가능하다.\n C와의 차이점 : C에서는 자체 문법으로 명시적(explicit) 혹은 묵시적(implicit) 방식으로 형변환을 했지만, 파이썬은 데이터형의 예약어를 이름으로 갖는 내장 함수를 사용해 형변환을 한다.\n 1. 정수로 변환 int(변환할 값)함수를 사용해 값을 변환한다.\n\u0026gt;\u0026gt;\u0026gt; int(4.26) 4 \u0026gt;\u0026gt;\u0026gt; int(\u0026#34;-4\u0026#34;) -4 \u0026gt;\u0026gt;\u0026gt; int(True) 1 \u0026gt;\u0026gt;\u0026gt; int(False) 0  실수형은 소숫점 이하를 버린다. True는 1, False는 0으로 변환된다. 문자열은 읽는 것처럼 변환해 준다.  무슨 말이냐 하면, 2번째 줄의 코드 int(\u0026quot;-4\u0026quot;)는 문자열을 정수로 변환한 것인데, 액면가(?) 그대로 인식해 사람이 읽는 것처럼 값으로 변환해 주는 것을 볼 수 있다.\n그렇다면 이런 코드를 실행하면 어떻게 될까?\n\u0026gt;\u0026gt;\u0026gt; int(\u0026#34;Hello, python!\u0026#34;) 다음과 같은 에러가 발생한다.\n\r문자열은 항상 정수로 변환될까?\r\n2. 실수로 변환 정수형과 마찬가지로, float(변환할 값) 함수를 사용해 값을 변환한다.\n\u0026gt;\u0026gt;\u0026gt; float(7) 7.0 \u0026gt;\u0026gt;\u0026gt; float(\u0026#34;-4.26\u0026#34;) -4.26 \u0026gt;\u0026gt;\u0026gt; float(True) 1.0 \u0026gt;\u0026gt;\u0026gt; float(False) 0.0 실수형과 크게 다르지 않은 결과를 보인다.\n 정수형은 소수점 이하를 .0으로 저장한다. True는 1.0, False는 0.0으로 변환된다. 문자열은 읽는 것처럼 변환해 준다.  그리고 (예상했겠지만) 다음과 같은 문자열 변환은 실수형과 마찬가지로 에러를 반환한다.\n\u0026gt;\u0026gt;\u0026gt; float(\u0026#34;Hello, python!\u0026#34;) \r실수형도 에러가 발생한다.\r\n3. 문자열로 변환 문자열로 변환하려면 str(변환할 값)함수를 사용한다.\n\u0026gt;\u0026gt;\u0026gt; str(4) \u0026#39;4\u0026#39; \u0026gt;\u0026gt;\u0026gt; str(-3.22) \u0026#39;-3.22\u0026#39; \u0026gt;\u0026gt;\u0026gt; str(True) \u0026#39;True\u0026#39; \u0026gt;\u0026gt;\u0026gt; str(False) \u0026#39;False\u0026#39; 변환 결과가 전부 ' '로 감싸진 문자열이다.\n4. 부울형으로 변환 부울형으로 변환하려면 bool(변환할 값)함수를 사용한다.\n\u0026gt;\u0026gt;\u0026gt; bool(4) True \u0026gt;\u0026gt;\u0026gt; bool(-3.22) True \u0026gt;\u0026gt;\u0026gt; bool(0) False \u0026gt;\u0026gt;\u0026gt; bool(0.0) False \u0026gt;\u0026gt;\u0026gt; bool(\u0026#34;Hello, python!\u0026#34;) True \u0026gt;\u0026gt;\u0026gt; bool(\u0026#39;\u0026#39;) False  0, 0.0, 빈 문자열은 False가 된다. 그 이외의 값은 전부 True가 된다.  6. 리스트, 튜플, 딕셔너리 파이썬을 제대로 사용하려면 반드시 이해하고 있어야 하는 핵심적인 자료형들이다.\n 리스트  0개 이상의 요소가 나열(Sequence)된 자료형 요소의 추가 및 삭제, 덮어쓰기가 가능(mutable)하다. 요소를 [ ]로 감싸서 만든다.   튜플  0개 이상의 요소가 나(Sequence)열된 자료형 한 번 만들어지고 나면 변경이 불가능하다(immutable). 요소를 ( )로 감싸서 만든다.   딕셔너리  키(Key)와 값(Value)의 쌍으로 이루어진 자료형 키(Key)는 인덱스(Index) 역할을 하며, 다른 키(Key)와 중복될 수 없다. 값(Value)은 키에 연결되며, 다른 값(Value)과 중복될 수 있다.     C와의 차이점\n리스트와 튜플은 C의 \u0026lsquo;배열(Array)\u0026lsquo;과 사용법이나 특징이 거의 동일하다. 리스트는 수정 가능한 배열, 튜플은 수정 불가능한 배열로 보아도 무방하다.\n 어차피 동일하다면, 값을 수정할 수 없는 튜플이 무슨 의미가 있는가? 라는 생각이 들 수도 있다.\n그러나 리스트에 비해 메모리를 적게 소비하고, 데이터를 실수로라도 변경할 수 없다는 점 등에서 차이가 난다.\n결국 적재적소에 잘 사용하는 것이 중요하다.\n1. 리스트 리스트는 0개 이상의 요소를 ,로 구분하여 [ ]를 사용해 선언한다.\n요소는 어떤 데이터형도 가능하다. 숫자, 문자, 부울뿐만 아니라 리스트, 튜플, 딕셔너리도 가능하다.\n\u0026gt;\u0026gt;\u0026gt; Months = [\u0026#34;January\u0026#34;, \u0026#34;February\u0026#34;, ..., \u0026#34;December\u0026#34;] \u0026gt;\u0026gt;\u0026gt; Friends = [\u0026#34;Alan\u0026#34;, \u0026#34;Crystal\u0026#34;, \u0026#34;Sally\u0026#34;] \u0026gt;\u0026gt;\u0026gt; Coffees = [\u0026#34;Americano\u0026#34;, \u0026#34;Espresso\u0026#34;, \u0026#34;Latte\u0026#34;, \u0026#34;Macchiato\u0026#34;, \u0026#34;Einspanner\u0026#34;] 특정 값을 참조하려면 리스트명 뒤에 [번호]를 붙이며, 값을 변경할 수도 있다.\n번호는 0부터 시작한다.\n\u0026gt;\u0026gt;\u0026gt; Months[2] \u0026#39;March\u0026#39; \u0026gt;\u0026gt;\u0026gt; Coffees[4] \u0026#39;Einspanner\u0026#39; \u0026gt;\u0026gt;\u0026gt; Friends [\u0026#39;Alan\u0026#39;, \u0026#39;Crystal\u0026#39;, \u0026#39;Sally\u0026#39;] append()메소드를 사용해 리스트 맨 끝에 요소를 추가할 수 있다.\n\u0026gt;\u0026gt;\u0026gt; Coffees.append(\u0026#34;Cappuccino\u0026#34;) \u0026gt;\u0026gt;\u0026gt; Coffees [\u0026#39;Americano\u0026#39;, \u0026#39;Espresso\u0026#39;, \u0026#39;Latte\u0026#39;, \u0026#39;Macchiato\u0026#39;, \u0026#39;Einspanner\u0026#39;, \u0026#39;Cappucchino\u0026#39;] insert()메소드를 사용해 지정한 위치에 요소를 추가할 수 있다.\n\u0026gt;\u0026gt;\u0026gt; Friends.insert(2, \u0026#34;No-Face\u0026#34;) \u0026gt;\u0026gt;\u0026gt; Friends [\u0026#39;Alan\u0026#39;, \u0026#39;Crystal\u0026#39;, \u0026#39;No-Face\u0026#39;, \u0026#39;Sally\u0026#39;] del 명령어를 사용해 리스트의 요소를 삭제할 수도 있다.\n\u0026gt;\u0026gt;\u0026gt; del Coffees[1] \u0026gt;\u0026gt;\u0026gt; Coffees [\u0026#39;Americano\u0026#39;, \u0026#39;Latte\u0026#39;, \u0026#39;Macchiato\u0026#39;, \u0026#39;Einspanner\u0026#39;, \u0026#39;Cappucchino\u0026#39;] del은 메소드가 아니라 파이썬 문법 내의 명령어이다. 따라서, Coffees.del(...)과 같은 방식으로 사용할 수 없다. 자세한 부분은 추후 클래스 챕터에서 다룬다.\n2. 튜플 튜플은 0개 이상의 요소를 ,로 구분하여 선언한다. ( )를 사용하지 않고도 선언 가능하지만, 튜플임을 명확히 나타내려면 ( )로 감싸 선언하는 편이 명확하다.\n보통 고정된 개수의 값을 포함하는 정보를 튜플에 묶어서 저장한다.\n본 교재의 목표는 게임 제작이다. 게임에서는 2차원상의 위치정보(x좌표, y좌표)를 저장할 필요가 있다.\n이와 같이 고정된 개수의 변수를 묶어서 저장하고 관리할 때는 튜플이 적합하다.\n\u0026gt;\u0026gt;\u0026gt; position = (40, 26) \u0026gt;\u0026gt;\u0026gt; position (40, 26) \u0026gt;\u0026gt;\u0026gt; position[0] 40 \u0026gt;\u0026gt;\u0026gt; position[1] 26 값을 변경할 수 없으므로 리스트의 append(), insert(), del등은 사용할 수 없다.\n튜플에는 독특한 사용법이 있다. 언팩(Unpack) : 하나의 튜플을 여러 변수에 대입하는 것\n\u0026gt;\u0026gt;\u0026gt; position = (40, 26) \u0026gt;\u0026gt;\u0026gt; position_x, position_y = position \u0026gt;\u0026gt;\u0026gt; position_x 40 \u0026gt;\u0026gt;\u0026gt; position_y 26 position이라는 이름의 튜플에 저장된 값이 position_x와 position_y에 나뉘어 저장된 것을 볼 수 있다.\n이를 응용하면 다음 작업도 가능하다.\n\u0026gt;\u0026gt;\u0026gt; x = 4 \u0026gt;\u0026gt;\u0026gt; y = 3 \u0026gt;\u0026gt;\u0026gt; (x, y) = (y, x) \u0026gt;\u0026gt;\u0026gt; x 3 \u0026gt;\u0026gt;\u0026gt; y 4 이는 마치 튜플의 값이 바뀐 것처럼 보이지만, 사실은 다음과 같은 과정을 거치게 된다.\n (y, x)가 3, 4으로 언팩된다. 새로운 튜플 (x, y)가 선언되고, 3, 4으로 초기화된다. x = 3, y = 4라는 값을 출력한다.  상기한 대로, 튜플의 값은 변화시킬 수 없다. 하지만 이는 튜플에 저장된 값을 수정하는 것이 아니라, 새로 선언된 튜플을 초기화하는 값으로 기존 튜플의 언팩을 사용한 것이다!\n3. 딕셔너리 말 그대로 사전처럼 쓸 수 있는 데이터 구조이다.\n리스트와 튜플에서는 숫자로 특정 값을 찾을 수 있었지만, 딕셔너리에서는 \u0026lsquo;키(Key)\u0026lsquo;로 \u0026lsquo;값(Value)\u0026lsquo;을 찾을 수 있다.\n선언 방법은 다음과 같다.\n\u0026gt;\u0026gt;\u0026gt; Profile = { \u0026#34;Name\u0026#34; = \u0026#34;Smith\u0026#34;, \u0026#34;Age\u0026#34; = 35, \u0026#34;Sex\u0026#34; = \u0026#34;M\u0026#34;, \u0026#34;Height\u0026#34; = 176, } \u0026gt;\u0026gt;\u0026gt; Profile {\u0026#39;Name\u0026#39;: \u0026#39;Smith\u0026#39;, \u0026#39;Age\u0026#39;: 35, \u0026#39;Sex\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;Height\u0026#39;: 176} \u0026gt;\u0026gt;\u0026gt; Profile[\u0026#34;Name\u0026#34;] \u0026#39;Smith\u0026#39; \u0026gt;\u0026gt;\u0026gt; Profile[\u0026#34;Age\u0026#34;] = 36 \u0026gt;\u0026gt;\u0026gt; Profile {\u0026#39;Name\u0026#39;: \u0026#39;Smith\u0026#39;, \u0026#39;Age\u0026#39;: 36, \u0026#39;Sex\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;Height\u0026#39;: 176} { }로 감싸고, (Key) : (Value)형태로 데이터를 작성한다. 키-값 쌍을 여러 개 저장하고 싶으면 ,로 구분한다.\n키와 값은 임의의 데이터형을 모두 사용할 수 있지만 일반적으로 키에는 문자열을 사용한다.\n딕셔너리의 요소를 참조하고자 할 때는 리스트/튜플과는 다르게 [] 내에 번호가 아닌 키 값을 지정한다.\n지금까지의 내용을 정리하면 다음과 같다.\n    리스트 튜플 사전     선언법 [ ] ( ) { }   데이터 구조 나열(Sequence) 나열(Sequence) K-V 쌍 (Dictionary)   참조 방식 변수명[번호] 변수명[번호] 변수명[키]   특징 수정 가능함 수정 불가함 순서가 없음    4. 다차원 리스트(튜플) 앞서 한 번 언급한 적 있지만, 리스트나 튜플은 또 다른 리스트나 튜플을 원소로 가질 수도 있다.\n C에서도 배열을 비슷한 방식으로 사용할 수 있다.\n배열의 원소가 배열인 경우를 2차원 배열이라고 부른다.\n 또한, 튜플의 원소가 리스트이거나, 리스트의 원소가 튜플일 수도 있다.\n이런 사용 방식에는 다음과 같은 특징이 따라오게 된다.\n 리스트의 원소가 튜플인 경우 해당 튜플이 쉽게 다른 것으로 대체될 수 있다. 튜플의 원소가 리스트인 경우 해당 리스트의 값을 수정할 수 있다.  각 자료형을 사용하는 이점이 흐려지는 느낌이 들기 때문에, 내 생각에는 이런 형태는 지양하는 편이 나을 듯 하다.\n마지막으로 예시를 하나만 살펴보자.\n학생 3명의 이름을 저장한 튜플, 학생 3명의 개인 성적을 저장한 튜플이 있다고 하자. 이 2개의 튜플을 요소로 갖는 또 다른 튜플을 다음과 같이 선언할 수 있다.\n\u0026gt;\u0026gt;\u0026gt; name = (\u0026#34;Alan\u0026#34;, \u0026#34;Crystal\u0026#34;, \u0026#34;Sally\u0026#34;) \u0026gt;\u0026gt;\u0026gt; score = (85, 97, 90) \u0026gt;\u0026gt;\u0026gt; data = (name, score) \u0026gt;\u0026gt;\u0026gt; data ((\u0026#39;Alan\u0026#39;, \u0026#39;Crystal\u0026#39;, \u0026#39;Sally\u0026#39;), (85, 97, 90)) 3번째 학생인 'Sally'의 성적은 score[2]로도 조회가 가능하지만, data[0][2]로도 조회할 수 있다. data[0]에 저장된 요소가 score이기 때문이다!\n위의 예시에서는 각각 튜플을 미리 선언한 후, 해당 튜플의 이름을 새로운 튜플의 요소로 넣었지만 전체를 직접 작성하는 것도 가능하다.\n\u0026gt;\u0026gt;\u0026gt; data = ((\u0026#34;Alan\u0026#34;, \u0026#34;Crystal\u0026#34;, \u0026#34;Sally\u0026#34;), (85, 97, 90)) \u0026gt;\u0026gt;\u0026gt; data ((\u0026#39;Alan\u0026#39;, \u0026#39;Crystal\u0026#39;, \u0026#39;Sally\u0026#39;), (85, 97, 90)) 그리고 책에는 추가적인 예시로 틱택토 게임을 리스트의 리스트를 사용해 나타낼 수 있는 방법에 대해서도 소개하고 있었는데, 해당 부분은 생략하기로 한다.\n원래 이번 글에 챕터의 모든 내용을 정리하려 했으나 생각보다 길어지는 관계로, 리스트 및 튜플에 관련된 함수들은 다음 포스팅에서 다루기로 한다.\n(다음 글에서 계속됩니다.)\n","date":"2021-03-22T00:00:00Z","image":"https://everimind4.github.io/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-2/cover_hu0583afeab19a2de7dc49fcc1be6b44c7_761261_120x120_fill_box_smart1_2.png","permalink":"https://everimind4.github.io/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-2/","title":"데이터형과 데이터 구조 (2)"},{"content":"1. 연산 1.1 기본 연산자 코딩을 조금이라도 공부해 본 사람은 알겠지만, 파이썬에서는 여타 수많은 프로그래밍 언어와 마찬가지로 다양한 연산자를 지원하고 있다.\n    수학에서의 기호 파이썬에서의 기호     덧셈 + +   뺄셈 - -   곱셈 × *   나눗셈 ÷ /     주의할 점은, 자료형(정수형, 실수형, \u0026hellip;)에 따라 계산 방식이 조금씩 다를 수 있다는 것이다.  또, Python IDLE Shell에서는 파이썬 코드를 입력하면 실행 결과가 바로 출력되는 것을 볼 수 있다.\n\rPython IDLE Shell :: 사칙연산\r\n그리고 맨 아래 계산 (4 * 2) / 6을 보면 알 수 있겠지만, 일반적인 수학적 표현에서와 마찬가지로 괄호( )를 이용해 계산의 우선순위를 지정할 수 있다.\n사칙연산 이외에도 여러 가지 연산자를 사용할 수 있다.\n   연산자 종류 기호     나눗셈의 나머지 구하기 %   나눗셈의 몫 구하기 //   지수(거듭제곱) 구하기 **    \rPython IDLE Shell :: 몫/나머지, 지수 계산\r\n 일반적인 나눗셈이 아닌 정수 나눗셈의 경우 몫과 나머지를 각각 %, // 연산자를 사용하여 계산한다. 파이썬에서는 거듭제곱을 계산할 때 ** 연산자를 사용하여 (밑) ** (지수) 형태로 나타낸다.  몫과 나머지를 한 번에 구하는 divmod() 함수도 있다.\n\u0026gt;\u0026gt;\u0026gt; divmod(26, 4) (6, 2) 2. 변수 프로그래밍에서 변수는 값을 저장하고, 저장된 값을 변경할 수 있다는 특징이 있다.\n파이썬의 변수 사용법도 다른 언어와 크게 다르지 않다.\n\u0026gt;\u0026gt;\u0026gt; a = 4 \u0026gt;\u0026gt;\u0026gt; b = 2 \u0026gt;\u0026gt;\u0026gt; a + b 6 \u0026gt;\u0026gt;\u0026gt; a * b 8 \u0026gt;\u0026gt;\u0026gt; a / b 2.0 다른 언어들과 마찬가지로 변수명을 정할 때는 몇 가지 규칙이 있다.\n  알파벳 대소문자, 숫자, 언더바(_)만 사용할 수 있다.\n  숫자는 맨 앞에 올 수 없다.\n  예약어(reserved word)는 변수명이 될 수 없다.\nex. if for return . . .\n  위 예시를 보면 알 수 있듯, 예약어는 특정 프로그래밍 언어 문법에서 이미 용도가 지정된 단어를 말한다.\n그리고 이쯤에서 한 마디 덧붙이자면, 책을 그대로 옮기는 듯한, 그러니까 일종의 아카이빙을 하는 느낌이 들기 시작했다.\n그래서 지금부터는 새롭게 배우게 된 내용을 정리하고, 이미 알고 있는 내용은 간단하게 요약하고 넘어가는 식으로 공부하기로 했다. 다른 프로그래밍 언어를 배우는 과정에서 이미 학습한 내용을 굳이 또 정리할 필요는 없기도 하고, 무엇보다도 현재 방식대로 진행하면 진도가 너무 느리다. 어쨌든 이제부터는 빠르게 진행해보기로 결정!\n3. 함수 지금까지 여러 연산자들을 살펴보았다.\n지금 살펴보는 함수는 이런 연산자들과 또 다른 함수들을 결합하여 특정 기능을 수행하도록 만든 것이다.\n다른 언어들과 마찬가지로, 파이썬의 함수도 함수명 뒤에 괄호 ( )를 붙여 실행한다.\n 함수명(인수1, 인수2, \u0026hellip; )  인수 : 함수에 전달되는 값 반환값 : 함수로부터 돌아오는 값    예를 들어 각각 인수 2개를 입력받아, 인수 2개를 더한 결과를 반환하는 sum이라는 함수와, 인수 2개 중 더 큰 값을 반환하는 max라는 함수가 있다고 하자. 그러면 다음과 같은 결과를 볼 수 있다.\n\u0026gt;\u0026gt;\u0026gt; sum(3, 5) 8 \u0026gt;\u0026gt;\u0026gt; max(4, 2) 4 max는 파이썬에 내장되어 있는 함수이고, sum은 + 연산자의 기능을 함수로 만든 것인데, 이런식으로 함수를 직접 만드는 방법은 아마 나중에 함수 파트에서 자세히 배우지 않을까 싶다.\n그리고 파이썬은 객체지향 언어이다. 즉, 객체에 딸린 함수들이 존재하고, **메소드(Method)**라고 부른다.\n일반적인 함수와 메소드의 차이는 다음과 같다.\n 함수 : 함수의 이름만 써서 원할 때 호출할 수 있다. 메소드 : 객체와 메소드 명을 모두 써야 하고, 객체가 존재해야만 호출할 수 있다.  이 부분도 마찬가지로 자세한 내용은 추후 객체 파트가 나온다면 학습하지 않을까 싶다.\n(다음 글에서 계속됩니다.)\n","date":"2021-03-15T00:00:00Z","image":"https://everimind4.github.io/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-1/cover_hu0583afeab19a2de7dc49fcc1be6b44c7_761261_120x120_fill_box_smart1_2.png","permalink":"https://everimind4.github.io/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-1/","title":"데이터형과 데이터 구조 (1)"},{"content":"교재 소개  파이썬을 공부하고자 좋은 교재가 없는지 찾아보다, 기초 문법도 학습할 수 있고 개인 프로젝트도 직접 만들어 볼 수 있는 교재를 발견하였다. 바로 게임으로 배우는 파이썬!   본 교재는 1부와 2부로 구성되어 있다.  1부에서는 파이썬의 기초 문법에 대해 학습 2부에서는 학습한 내용을 기초로 하여 직접 고전 게임을 만들어보는 프로젝트를 진행   따라서 해당 교재를 공부한 내용과 프로젝트를 수행한 결과물을 본 블로그 및 Github Repository에 업로드 할 예정이다!  1. 파이썬(Python) 소개 1.1 라이브러리 파이썬은 문법이 간단해 배우기 쉽지만, 그것만으로는 할 수 있는 일이 제한적이다.\n따라서 목적에 맞는 라이브러리를 로드해 사용한다.\n대표적인 라이브러리의 종류는 다음과 같다.\n NumPy : 수치 계산 SciPy : 과학 기술 계산 PIL : 영상처리 Tkinter : GUI(그래픽 유저 인터페이스) Beautiful Soup : HTML 정보 수집(스크래핑) PyGame : 게임 제작 파일을 읽고 쓰거나 네트워크 작업에 관련된 라이브러리 등의 표준 라이브러리 기타 수많은 3rd Party 라이브러리  이처럼 다양한 라이브러리들이 많은데, 이 책은 게임을 만드는 것을 목표로 하고 있으므로 PyGame은 무조건 사용할 것 같고, 나중에 다른 라이브러리도 사용하게 될 지 모를 일이다.\n1.2 설치  Python 3 설치 : Windows 사용자는 아나콘다 혹은 파이썬을 설치할 것 (현재 최신 버전 : 3.9.2) PyGame 라이브러리 다운로드  나는 아나콘다를 제외하고 파이썬만 여기서 다운받아 설치하였다.\n설치 완료 후 명령 프롬프트를 열어 pip install pygame 명령어를 입력한다.\n마찬가지로 설치가 완료되면, 파이썬을 실행해 import pygame 명령어로 설치 여부를 확인한다.\n\r이런 메시지가 출력되면 성공(인 것 같다)\r\nMacOS 설치 방법은 생략하도록 하겠다(찾아보면 금방 나오고 별로 다르지도 않다).\n다음 글에서는 Python의 자료형과 자료구조에 대해 학습할 예정이다.\n","date":"2021-03-10T00:00:00Z","image":"https://everimind4.github.io/p/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/cover_hu0583afeab19a2de7dc49fcc1be6b44c7_761261_120x120_fill_box_smart1_2.png","permalink":"https://everimind4.github.io/p/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/","title":"시작하기"},{"content":"1. Github 블로그  \u0026quot; 개발자라면 Github 블로그 하나 정도는 있어야지! \u0026quot;\n 라는 말을 어디선가 주워듣고 Github로 블로그를 만들어보자, 결심하게 되었다.\n그런데 생각보다 진입장벽이 낮지는 않았고, 익숙해지는 데 생각보다 시간이 걸린 데다 시행착오도 제법 겪으며 결국 어찌저찌 성공은 하였다(그 결과물을 지금 보고 계십니다).\n그래서 관련 내용을 정리해서 포스팅하면 Hugo로 블로그를 만들어 Github로 호스팅하고자 하는 사람들이 조금이나마 도움을 받을 수 있을 듯 하여, 첫 포스팅 주제는 블로그를 만드는 방법으로 결정!\n2. 준비물 각 항목 클릭 시 해당 설치 파일을 받을 수 있는 웹사이트로 링크 (OS에 맞는 최신 버전을 다운로드)\n Git Hugo  Hugo theme (마음에 드는 테마 하나 선택)   Typora (Markdown 에디터)  3. 설치하기 3.1. Git 설치  Hugo blog만 사용하고자 하는 경우 설치 옵션 그대로 유지 명령 프롬프트에 git version를 입력하여 잘 설치되었는지 확인  3.2. Github Repository 2개 만들기  '(Username).github.io' : 빌드 결과인 블로그 HTML 파일을 저장하는 Public Repository, 이름 양식 필히 준수 (everimind4.github.io)   Hugo blog 전체 파일을 관리하는 Private Repository, 이름 자유롭게 설정 (필자의 경우 blog로 설정)  3.3. 로컬 디렉토리 생성 및 구성   C:\\Hugo\\bin 디렉토리 생성 후 다운로드한 Hugo Zip 파일 압축 해제\n  Windows + Q ▶ 시스템 환경 변수 편집 ▶ PATH에 C:\\Hugo\\bin 추가\n  Git Bash 실행 후 C:\\Hugo 위치에서 $ hugo new site blog 명령으로 로컬 컨텐츠 디렉토리 생성\n C:\\Hugo\\blog에서 dir 명령으로 디렉토리 구조를 확인 가능 이후, Git Bash 속성에서 시작 위치를 C:\\Hugo\\blog로 설정하면 작업이 편해집니다!    3.4. 테마 다운로드 및 설정  2번에서 고른 테마의 github 저장소 주소를 복사 ~\\blog 경로에서 $ git init 명령 실행 후 $ git submodule add (복사한 주소) themes\\(테마 이름) 명령으로 테마를 submodule로 추가 config.toml 파일의 내용을 각 테마 Github 페이지의 예시 파일을 보면서 수정  toml이 아닌 yml/yaml 파일만 존재하는 경우 YAML to TOML converter 등을 사용    3.5. Github 원격 저장소와 로컬 디렉토리 연결  Github에 만든 blog 저장소(본인이 설정한 이름)와 C:\\Hugo\\blog 디렉토리 연결  C:\\Hugo\\blog로 이동 $ git init $ git remote add origin https://github.com/everimind4/blog.git   everimind4.github.io 저장소를 blog의 submodule로 등록  $ git submodule add -b main https://github.com/everimind4/everimind4.github.io.git public    3.6. 컨텐츠 생성  $ hugo new post/test.md 명령을 실행하면 blog\\content\\post\\ 위치에 test.md 파일이 생성됨 Typora 등의 Markdown Editor를 사용하여 md 파일 내용 작성 (자세한 방법을 다음 글에서 다룸) $ hugo server 또는 hugo server -D 명령어로 웹서버 실행  http://localhost:1313/에 접속해서 확인 md 파일의 Draft 옵션이 true로 설정된 경우 빌드에서 제외됨 -D 옵션은 md파일의 Draft 문서들도 확인 가능한 옵션 (다른 옵션은 여기서 확인)    3.7. 컨텐츠 업로드  C:\\Hugo\\blog로 이동 $ hugo -t (테마이름) 명령으로 테마가 적용된 블로그 내용을 ~\\public에 생성 $ cd public public 디렉토리로 이동 $ git add . 수정된 파일 내역 저장 $ git commit -m \u0026quot;(description)\u0026quot; 변경 내용 commit $ git push origin main everimind4.github.io에 커밋 내용 Push blog 저장소에도 변경 내용 Push  $ cd .. public의 한 단계 상위 디렉토리인 blog로 이동 $ git add . $ git commit -m \u0026quot;(description)\u0026quot; $ git push origin main    4. 마무리하며 여기까지 따라왔다면 블로그에 글을 작성하고 빌드하여 블로그의 기초를 다지는 방법은 모두 배우셨습니다.\n이어지는 글들을 통해 아래 내용들을 다룰 예정입니다.\n 블로그 세부 설정  config.toml 파일의 세부 내용을 수정하기 Disquss 등의 댓글 위젯 추가하기 Google Analytics 연동하기 sitemap.xml을 추가해 검색 엔진에 노출시키기   마크다운 에디터 Typora를 사용해 글쓰기  글 작성 Tips 기본적인 문법 및 단축키    ","date":"2021-02-20T00:00:00Z","permalink":"https://everimind4.github.io/p/%ED%9C%B4%EA%B3%A0hugo%EB%A1%9C-github-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-1/","title":"휴고(Hugo)로 Github 블로그 만들기 (1)"}]