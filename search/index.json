[{"content":"운영체제의 기능 프로그램은 CPU가 수행하는 인스트럭션(Instruction, 명령어)들의 목록이라고 생각할 수 있다.\n즉, 프로그램을 실행한다는 것은 인스트럭션을 수행하는 것이다.\n따라서 프로그램이 실행될 때는 다음과 같은 과정을 거치게 된다.\n  Fetch : 메모리에서 인스트럭션을 하나 가져온다.\n  Decode : 가지고 온 인스트럭션이 어떤 종류인지를 알아낸다.\n  Execute : 인스트럭션을 실제로 수행한다.\n여기까지 완료하면 하나의 인스트럭션을 수행한 것이다.\n  다음 인스트럭션을 찾는다.\n  프로그램이 실행되고 종료되기까지 이 4개의 과정이 계속 반복된다.\n운영체제는 프로그램이 원활하게 실행될 수 있도록 환경을 제공하는 역할을 한다.\n 프로그램을 실행하기 쉽도록 해 준다. 프로그램들이 메모리를 공유할 수 있도록 해 준다. 프로그램들이 외부 장치들과 정보를 주고받을 수 있도록 해 준다.  즉, 시스템이 올바르고 효율적으로 동작할 수 있도록 만드는 것이 OS의 역할이다.\n운영체제의 기능과 역할은 크게 3가지이다.\n Virtualization (가상화) Concurrency (병행성) Persistency (지속성)  지금부터 각각의 개념에 대해 간단하게 살펴본다.\nVirtualization (가상화) 운영체제의 가장 중요한 역할 중 하나는 시스템을 가상화하여 프로그램에게 제공하는 것이다.\n구체적으로는 시스템의 물리적 자원(Physical Resource)인 하드웨어(Hardward)를 프로그램이 사용하기 편리하도록 가상화하여 제공하는 것을 의미한다.\n가상화된 형태는 프로그램이 사용하기 편리하다. 실제 하드웨어의 구조 및 복잡한 작동 방식, 하드웨어 공유 시 발생하는 문제 등을 신경쓰지 않아도 되기 때문이다.\n이러한 특징 때문에 운영체제를 Virtual Machine이라고 부르기도 한다.\nSystem call 시스템 자원은 가상화되어 있으므로, 프로그램들은 시스템 자원에 직접 접근할 수 없다. 따라서 프로그램들은 시스템 자원을 사용하려면 운영체제에게 요청해야 한다.\n운영체제에게 시스템 자원을 요청하기 위해 특수한 함수인 System call(시스템 콜)을 사용한다.\n운영체제는 프로그램들이 사용할 수 있는 다양한 시스템 콜을 제공한다.\nResource manager 운영체제는 CPU, Memory, Disk 등의 시스템 자원을 (가상화할 뿐만 아니라) 관리하는 역할을 한다.\n여러 프로그램들이 동시에 실행될 수 있도록 CPU를 공유하기도 하고, 각 프로그램이 사용할 수 있도록 메모리 및 디스크를 공유해 주기도 한다.\n즉, OS가 여러 프로그램들 사이에서 시스템 자원을 분배하는 중재자 역할을 한다.\nCPU 가상화 실행하고자 하는 프로그램의 개수에 비해 CPU의 개수는 너무나 적다.\n하지만 CPU가 단 하나만 존재하는 경우에도, CPU 가상화를 통해 여러 프로그램이 적은 수의 CPU를 동시에 사용할 수 있다.\nOS는 각 프로그램들에게 자신만의 전용 CPU를 가지고 있다는 환상을 제공해 준다. 즉, 하나의 프로세스로 여러 프로그램을 실행하더라도 각 프로그램들은 자신만의 CPU를 가지고 있는 것처럼 작동한다.\n메모리 가상화 CPU와 마찬가지로 실제 물리적인 메모리를 여러 프로그램이 사용할 수 있게 해 주는 것이 메모리 가상화이다.\n실제 메모리는 정보를 저장 가능한 바이트(Byte)들로 이루어진 저장 공간이다. 즉, **바이트의 배열(An array of Bytes)**로 생각할 수 있다. 각 바이트에는 고유한 번호가 존재하고, 이를 **주소(Address)**라고 한다. 이 주소를 가지고 메모리를 읽고 쓸 수 있다.\nOS는 각 프로그램들에게 자신만의 전용 메모리를 가지고 있다는 환상을 제공해 준다.\n하지만 각 프로그램에는 실제 주소(Physical Address)가 아닌 가상 주소(Virtual Address)가 제공된다.\n따라서 현재 실행 중인 프로그램들이 모두 동일한 주소에 접근하는 것 처럼 보이는 경우에도, 실제로는 다른 주소에 접근하게 된다.\nOS가 중간에서 가상 주소를 실제 주소로 연결해 주기 때문에, 이러한 경우에도 프로그램들은 문제 없이 작동할 수 있다.\nConcurrency (병행성) 병행성은 여러 프로그램들이 동시에 실행되어야 하기 때문에 발생하는 특징이다.\n다음과 같은 코드를 통해 병행성의 특징을 볼 수 있다.\n// thread.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int counter = 0; int loops; void *worker(void *arg) { int i; for (i = 0; i \u0026lt; loops; i++) counter++; return NULL; } int main(int argc, char *argv[]) { . . . // Exception Handler  loops = atoi(argv[1]); printf(\u0026#34;Initial Value : %d\\n\u0026#34;, counter); pthread_t p1, p2; Pthread_create(\u0026amp;p1, NULL, worker, NULL); Pthread_create(\u0026amp;p2, NULL, worker, NULL); Pthread_join(p1, NULL); Pthread_join(p2, NULL); printf(\u0026#34;Final Value : %d\\n\u0026#34;, counter); return 0; } worker 함수는 전역 변수인 counter에 저장된 값을 1씩 증가시키는 함수이다.\nworker 함수를 main 함수 내에서 멀티스레드(Multi-thread)를 활용해 동시에 1000번씩 작동시킨다고 생각해 보자.\n$ gcc -o thread thread.c -Wall -pthread $ ./thread 1000 Initial Value : 0 Final Value : 2000 당연한 결과이다. 하지만 loops의 값이 커지게 되면 이상한 현상이 발생한다.\n$ ./thread 100000 Initial Value : 0 Final Value : 106296 $ ./thread 100000 Initial Value : 0 Final Value : 107258 예상대로라면 200000이 출력되어야 하지만, 그에 훨씬 못 미치는 값이 출력되는 것을 볼 수 있다. 더욱 심각한 것은, 조건 분기 등이 없음에도 매번 값이 다르게 출력된다는 사실이다. 이는 대표적인 병행성 문제이다.\n왜 이런 현상이 발생하는지는 내부 인스트럭션의 구조를 보면 알 수 있다. worker 함수는 최소 3개의 인스트럭션으로 이루어져 있다.\n Load : 메모리에서 counter 변수의 값을 읽는다. Increment : 해당 변수의 값을 1 증가시킨다. Store : 증가시킨 값을 다시 원래 위치에 저장한다.  문제는 두 스레드를 통해 실행되는 이 인스트럭션들이 서로 중첩되는 경우이다. 각 스레드의 인스트럭션들은 개별 스레드 내부에서는 순서대로 실행되지만, 멀티스레드의 경우 서로 끼어들 수 있다.\n   스레드 인스트럭션 수행하는 기능 counter     1 Load counter 변수를 불러온다 0   2 Load counter 변수를 불러온다 0   1 Increment 값을 1 증가시킨다 (0 → 1) 0   1 Store 증가시킨 값 1을 counter 변수에 저장한다 1   2 Increment 값을 1 증가시킨다 (0 → 1) 1   2 Store 증가시킨 값 1을 counter 변수에 저장한다 1    실제로 개별 스레드에서 한 번씩, 반복문이 총 2회 실행되었지만 내부 인스트럭션들이 중첩되는 바람에 의도와 다르게 실행되었음을 알 수 있다.\n이를 방지하기 위해서는 공유된 자원을 읽어와서 값을 증가시키고 저장하기까지의, 위에 나열한 최소 3개의 인스트럭션들이 한 묶음으로(Atomic) 실행되어야 한다.\nPersistency (지속성) 일반적으로 메인 메모리로 사용하는 DRAM은 휘발성(volatile) 저장 장치이다. 휘발성은 전원을 차단하면 저장된 정보가 삭제되는 특징을 말한다.\n따라서 데이터를 보존하기 위해 하드웨어나 소프트웨어의 도움을 받는다.\n 하드웨어(Hardware) : 입출력 장치인 하드 디스크 드라이브(HDD), 솔리드-스테이트 드라이브(SDD) 소프트웨어(Software) : 운영체제의 파일 시스템(File System)  운영체제는 시스템에 연결된 HDD나 SSD와 같은 저장 공간을 추상화하여 제공하며, 저장된 파일을 관리하는 **파일 시스템(File System)**을 갖고 있다.\n프로그램이 파일을 열거나 수정해 저장하는 등의 파일 관련 작업을 수행하려면 시스템 콜을 요청해야 한다.\n지속성(Persistency)은 디렉토리와 파일로 추상화된 공간을 통해 데이터를 보존하는 것을 말한다.\n운영체제가 갖는 지속성(Persistency)의 특징은 다음과 같다.\n 프로그램의 요청을 받아 어느 위치에 있는 파일을 수정하거나 새로운 파일을 작성할 지를 결정한다. 파일시스템은 파일 작성 중 오류가 발생한 경우 Journaling이나 Copy-on-Write등의 방식을 사용해 오류를 복구한다.  운영체제 설계 목표  Abstraction : 추상화 및 가상화를 통해 사용 편의성을 더한다. High Performance : 성능이 뛰어나야 한다.좋아야 한다. 하드웨어에 OS가 설치된 후 그 위에 다른 모든 프로그램들이 설치되기 때문에, OS의 성능이 비효율적인 경우 다른 모든 프로그램들의 성능이 저하된다. Protection (Isolation) : 프로그램 간의 간섭을 방지해야 한다. 특정 프로그램이 다른 프로그램의 데이터를 훼손하거나 덮어쓰는 경우를 막을 수 있어야 한다. Reliability : OS는 항상 작동해야 한다. OS가 작동을 멈추면 전체 프로그램들도 작동할 수 없게 되고, 컴퓨터를 사용할 수 없게 된다. Others : Energy-efficiency, Security, Mobility, . . .  앞으로 위에서 살펴본 3가지 요소인 Virtualization, Concurrency, Persistency에 관한 내용을 주제별로 살펴볼 예정이다.\n","date":"2021-04-16T00:00:00Z","permalink":"https://everimind4.github.io/p/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%9C%EC%9A%94/","title":"운영체제 개요"},{"content":"1. 들여쓰기(Indentation)  C에서는 코드 실행 단위인 블록을 구분하기 위해 중괄호{ }를 사용하고, 들여쓰기는 가독성을 증진시키는 데만 사용되는 개념이었다.\n하지만 파이썬에서는 들여쓰기 수준으로 코드 블록을 구분한다.\n C/C++ Style if (조건문) { 명령1; 명령2; } Python Style if a \u0026gt; b: 명령1 명령2 C와 비교했을 때, Python의 문법적 차이는 다음와 같다.\n 조건문을 괄호( )로 싸지 않고 콜론:을 조건문 뒤에 적는 것으로 간단하게 사용한다. 명령문의 끝에 세미콜론;을 적지 않는다. (적어도 상관은 없음) 코드 블록을 감싸는 중괄호{ }를 생략한다. 대신 들여쓰기(Indentation)로 코드 블록을 구분한다.  그리고 마지막 항목인 중괄호 생략이 바로 파이썬의 가장 큰 특징이다. 자세한 내용은 조건식에서 추가적으로 다룬다.\n2. 조건식 조건식으로 입력되는 부울값에 따라 제어문에 의해 실행되는 코드가 달라진다(코드의 흐름이 달라진다).\n비교연산자 두 개의 값을 비교하고 부울값을 반환한다.\n   연산자 반환값     A == B 두 값이 서로 같으면 True, 아니면 False   A != B 두 값이 서로 다르면 True, 아니면 False   A \u0026lt; B A가 B보다 작으면 True, 아니면 False   A \u0026lt;= B A가 B보다 작거나 같으면 True, 아니면 False   A \u0026gt; B A가 B보다 크면 True, 아니면 False   A \u0026gt;= B A가 B보다 크거나 같으면 True, 아니면 False   A in B A가 B(리스트 or 튜플)에 포함된(B의 요소 중 A가 존재) 경우 True, 아니면 False    부울연산자 부울연산자의 피연산자로 비교연산자 등의 조건식을 조합하여 사용할 수 있다.\n   A B AND OR     True True True True   True False False True   False True False True   False False False False    not은 입력값과 반대되는 부울값을 반환한다. 이를 정리하면 다음과 같다.\n   연산자 반환값     조건식1 and 조건식2 조건 1과 조건 2가 모두 True이면 True, 아니면 False   조건식1 and 조건식2 조건 1과 조건 2중 하나만 True여도 True, 아니면 False   not 조건식 조건식이 True이면 False, False이면 True 반대되는 부울값을 반환한다.    부울 이외의 데이터형 위 2개 연산자의 경우 부울값을 반환하므로 조건식으로 사용할 수 있지만, 부울값 이외의 값도 조건식으로 사용할 수 있다. 그대로 사용하는 것은 아니고, 부울값으로 데이터형을 변환한 후 조건식으로 사용한다.\n   데이터형 True False     수치 0(0.0) 0 이외의 값   문자열 빈 문자열 '', \u0026quot;\u0026quot; 비어있지 않은 문자열   리스트, 튜플 비어있는 리스트[ ], 튜플( ) 요소가 하나라도 있는 경우    bool() 함수를 사용해 변환 결과를 알아볼 수 있다.\n\u0026gt;\u0026gt;\u0026gt; bool(0) False \u0026gt;\u0026gt;\u0026gt; bool(0.0) False \u0026gt;\u0026gt;\u0026gt; bool(426) True \u0026gt;\u0026gt;\u0026gt; bool(2.718) True \u0026gt;\u0026gt;\u0026gt; bool({}) False \u0026gt;\u0026gt;\u0026gt; bool((1, 2, 3)) True \u0026gt;\u0026gt;\u0026gt; bool(\u0026#34;Hello, Python!\u0026#34;) True \u0026gt;\u0026gt;\u0026gt; bool(\u0026#39;\u0026#39;) False 3. 조건문  코드 블록을 콜론:과 들여쓰기만으로 구분한다는 점을 제외하면 C와 거의 동일하다.\n들여쓰기로 코드 블록을 구분하는 것을 구체적으로 살펴보기 위해 각 경우의 코드 예시를 살펴본다.\n if: ~ else: 조건문이 True일 경우 if 바로 뒤 블록 내의 코드를 실행하고, False일 경우 else 뒤 블록의 코드를 실행한다.\n\u0026gt;\u0026gt;\u0026gt; a = 4 \u0026gt;\u0026gt;\u0026gt; b = 2 \u0026gt;\u0026gt;\u0026gt; if a \u0026gt; b: print(a + b) else: print(a - b) 6 \u0026gt;\u0026gt;\u0026gt; if a \u0026lt; b: print(a + b) else: print(a - b) 2 동일한 if문을 실행했음에도 조건식의 값에 따라 다른 결과가 나타나는 것을 볼 수 있다.\nif: 단독 사용 False인 경우를 고려할 필요가 없는 경우 if문을 단독으로 사용한다.\n\u0026gt;\u0026gt;\u0026gt; subject = {\u0026#34;Korean\u0026#34;, \u0026#34;Math\u0026#34;, \u0026#34;English\u0026#34;} \u0026gt;\u0026gt;\u0026gt; score = {} \u0026gt;\u0026gt;\u0026gt; if subject: print(subject) {\u0026#39;Korean\u0026#39;, \u0026#39;Math\u0026#39;, \u0026#39;English\u0026#39;} \u0026gt;\u0026gt;\u0026gt; if score: print(score) \u0026gt;\u0026gt;\u0026gt; subject 리스트에는 요소가 존재하므로 해당요사가 출력되고, score리스트에는 요소가 없으므로 아무런 일도 일어나지 않는다.\nif: elif: else elif는 else if를 줄인 형태이다. 사용법은 C와 동일하므로 추가로 예시를 살펴보지는 않는다.\n4. 반복문  파이썬의 반복문은 C와 동일하게 while과 for가 있다.\n while while (조건문): 명령1 명령2 명령3 이런 형태의 코드의 경우 조건문이 True에서 False가 되기 전까지 명령1, 명령2를 반복해서 수행하다 while루프가 종료되면 명령3을 실행하게 된다.\nfor  python의 for문은 C에 비해 매우 직관적이다.\n for문의 기본적인 구조는 다음과 같다.\nfor (변수) in (리스트, 튜플, 문자열 등): 명령1 명령2 . . . 즉, in뒤의 데이터형에서 요소를 하나씩 꺼내어(문자열의 경우 문자를 하나씩) 변수에 넣고, 명령을 처리한다.\n복잡한 응용도 가능하다. 변수 위치에 꼭 단일 변수만 와야 하는 것은 아니고, 특정 자료형도 위치할 수 있다.\nfor (a, b) in [(1, 2), (3, 4), (5, 6)]: print(a) print(b) print(\u0026#34;next\u0026#34;) 1 2 next 3 4 next 5 6 next 오른쪽 2차원 리스트의 각 요소인 튜플이 자동으로 왼쪽 튜플의 요소에 언팩되어 들어간다.\nfor ~ range() 기존의 C에서처럼 숫자를 증가시키는 반복문 형태도 있다. range()함수와 함께 사용한다.\nrange(숫자)는 0에서부터 (해당 숫자-1)까지의 정수들을 요소로 하는 리스트(튜플)처럼 사용할 수 있다.\nrange()의 인수는 1개부터 3개까지 입력 가능한데, 각각 다음 의미를 갖는다.\n   인수의 개수 1번째 인수 2번째 인수 3번째 인수     1개 입력 마지막 숫자 X X   2개 입력 시작 숫자 마지막 숫자 X   3개 입력 시작 숫자 마지막 숫자 증가폭    인수를 1개만 입력하는 경우 0부터 시작하는 것으로 인식한다.\n\u0026gt;\u0026gt;\u0026gt; print(range(4)) range(0, 4) 각 경우를 직접 출력해보면 다음과 같은 결과를 볼 수 있다.\n\u0026gt;\u0026gt;\u0026gt; for i in range(4): print(i) 0 1 2 3 \u0026gt;\u0026gt;\u0026gt; for j in range(2, 6): print(j) 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; for k in range(5, 15, 3): print(k) 5 8 11 14 break, continue  C에서와 동일하게 사용할 수 있다.\n  break : 반복 도중 반복문을 강제로 벗어난다. continue : 반복 도중 반복문의 맨 앞으로 돌아간다.  C와 차이가 없으므로 구체적인 설명은 생략한다.\n다음 글에서는 파이썬에서 함수를 정의하는 방법과, 기존에 정의된 함수 모음인 모듈에 대해 다룰 예정이다.\n(다음 글에서 계속됩니다.)\n","date":"2021-04-05T00:00:00Z","image":"https://everimind4.github.io/p/%EC%A0%9C%EC%96%B4%EB%AC%B8-1/cover_hu0583afeab19a2de7dc49fcc1be6b44c7_761261_120x120_fill_box_smart1_2.png","permalink":"https://everimind4.github.io/p/%EC%A0%9C%EC%96%B4%EB%AC%B8-1/","title":"제어문 (1)"},{"content":"7. 관련 함수들 len 리스트나 튜플 내의 요소 개수를 반환하는 함수이다.\n\u0026gt;\u0026gt;\u0026gt; len([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]) 4 \u0026gt;\u0026gt;\u0026gt; len([2, 3, 5, 7, 11, 13]) 6 대상 요소가 무엇이든 전체 개수만 반환하므로, 2차원 이상의 리스트 혹은 튜플의 경우에는 다음과 같은 결과를 확인할 수 있다.\n\u0026gt;\u0026gt;\u0026gt; fibonacci = [[1, 1, 2, 3, 5, 8], [13, 21, 34, 55, 89], [144, 233, 377, 610, 987]] \u0026gt;\u0026gt;\u0026gt; len(fibonacci) 3 \u0026gt;\u0026gt;\u0026gt; len(fibonacci[2]) 5 copy 리스트를 복제하는 (리스트) 메소드이다.\n C에서는 Shallow copy(얕은 복사)와 Deep copy(깊은 복사)를 구별한다. C에서는 특히 Dangling pointer의 발생을 방지하려면 이 둘의 차이에 대해 잘 이해해야 하는데, 파이썬에도 이 둘의 차이를 구분한다.\n 그냥 대입하는 방식으로 리스트를 복사하면 얕은 복사가 일어난다. 다음 코드를 보면 문제가 있음을 알 수 있다.\n\u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; b = a \u0026gt;\u0026gt;\u0026gt; a[2] = 9 \u0026gt;\u0026gt;\u0026gt; a [1, 2, 9] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 9] 같은 리스트를 참조하기 때문에 이와 같은 문제가 발생한다. C에서는 직접 또다른 메모리 공간을 할당받는 등의 방법을 사용하지만, 파이썬에서는 copy 함수로 이와 같은 문제를 해결한다.\n\u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; b = a.copy() \u0026gt;\u0026gt;\u0026gt; a[2] = 9 \u0026gt;\u0026gt;\u0026gt; a [1, 2, 9] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3] 이를 통해 copy 메소드는 서로 다른 리스트를 참조하도록 만들 수 있고, 얕은 복사가 아닌 깊은 복사가 수행 가능함을 알 수 있다.\n리스트를 복제하고 싶을 때 copy 메소드를 사용할 수 있다.\n단, 튜플은 값을 변경할 수 없으므로 copy 메소드를 사용할 수 없다.\nin 어떠한 값이 리스트나 퓨틀 내에 존재하는지 확인하기 위한 함수이다.\n\u0026gt;\u0026gt;\u0026gt; subjects = (\u0026#34;Korean\u0026#34;, \u0026#34;English\u0026#34;, \u0026#34;Math\u0026#34;, \u0026#34;Science\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#34;Math\u0026#34; in subjects True \u0026gt;\u0026gt;\u0026gt; \u0026#34;Music\u0026#34; in subjects False 알고 싶은 값 in 리스트(or 튜플) 의 형태로 사용한다. 값이 포함되어 있으면 True, 그렇지 않으면 False가 반환된다.\nindex in함수는 단순히 포함 여부를 확인할 수 있다면, index 메소드는 요소의 위치를 알려 준다.\n\u0026gt;\u0026gt;\u0026gt; weekdays = (\u0026#34;Mon\u0026#34;, \u0026#34;Tue\u0026#34;, \u0026#34;Wed\u0026#34;, \u0026#34;Thu\u0026#34;, \u0026#34;Fri\u0026#34;, \u0026#34;Sat\u0026#34;, \u0026#34;Sun\u0026#34;) \u0026gt;\u0026gt;\u0026gt; weekdays.index(\u0026#34;Tue\u0026#34;) 1 \u0026gt;\u0026gt;\u0026gt; weekdays.index(\u0026#34;Fri\u0026#34;) 4 요소를 찾을 수 없는 경우에는 에러가 발생한다.\nsort vs sorted   sorted\nsorted는 함수이다. 인수로 주어진 리스트나 튜플을 정렬한 후 복사본을 반환한다.\n원래 리스트의 요소 순서는 변하지 않는다.\n  sort\nsort는 (리스트) 메소드이다. 해당 리스트를 정렬하고, 반환 값은 없다.\n즉, 해당 리스트의 요소들이 실제로 순서가 바뀌어 정렬된다.\n  print print는 인수로 주어진 정보를 콘솔에 출력하는 함수이다.\n콘솔 출력 함수인 print는 튜플( )과 조합하여 다양한 방식으로 사용할 수 있다.\n  % 연산자\n C에서는 printf() 함수 내에 1번째 매개변수로 형식지정자(ex. 정수 %d, 문자 %c, 실수 %f)를 포함하는 문자열을 넣고, 2번째 매개변수로 각 형식지정자에 해당하는 변수를 ,로 구분하여 입력한다.\n 파이썬에서는 문자열 내에 %s(문자열 형식), %d(정수형) 등의 서식을 삽입하고, 해당 문자열 뒤에 % 연산자, 그리고 그 뒤에 튜플 형식으로 출력할 데이터를 배치한다.\n문자열 지정 형식은 C와 거의 동일하다.\n   문자열 10진수 16진수 부동소수     %s %d %x %f    \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;제 이름은 %s입니다. 저는 %dcm입니다.\u0026#34; % (\u0026#34;홍길동\u0026#34;, 185)) \u0026#34;제 이름은 홍길동입니다. 저는 185cm입니다.\u0026#34; 당연하지만 사전에 튜플을 선언하고 사용할 수도 있다. (오히려 이 경우가 좀 더 일반적인 것 같다.)\n\u0026gt;\u0026gt;\u0026gt; score = (96, 88) \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;수학 : %d점, 영어 : %d점\u0026#34; % score) \u0026#34;수학 : 96점, 영어 : 88점\u0026#34; 지정 형식과 다른 데이터형을 입력하는 경우 에러가 발생하므로 형식 지정 및 값 입력 시에 주의를 요한다.\n  .format() 메소드\n% 연산자를 사용하는 방식과 비교하면 기본적으로 2가지 차이가 있다.\n  데이터를 삽입하고 싶은 곳에 %d등의 형식 대신 { }을 사용\n  print에 인수(매개변수)로 전달하는 대신 해당 자료형의 메소드 형태로 호출\n  % 연산자와 비교하면 다음과 같다.\n\u0026gt;\u0026gt;\u0026gt; score = (96, 88) \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;수학 : {}점, 영어 : {}점\u0026#34;.format(score[0], score[1])) \u0026#34;수학 : 96점, 영어 : 88점\u0026#34; 그러나 { }내에 번호를 지정하거나 이름을 붙이는 방식으로도 사용할 수 있다!\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#34;수학 : {1}점, 영어 : {0}점\u0026#34;.format(96, 88)) \u0026#34;수학 : 88점, 영어 : 96점\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;수학 : {수학}점, 영어 : {영어}점\u0026#34;.format(수학 = 96, 영어 = 88)) \u0026#34;수학 : 96점, 영어 : 88점\u0026#34; 이 밖에도 C에서와 유사하게 서식 문자열을 사용해 자릿수 지정, 좌/우 정렬, 패딩을 주는 등의 다양한 서식 지정 등이 가능하다(고 한다).\n  8. 주석(Comment) 다른 수많은 언어에서도 사용되는 개념으로, 간단하게 말하면 프로그램에 관한 개발자의 메모이다.\npython에서는 기본적으로 1행짜리 주석만 지원한다.\n# 이 행은 주석입니다. # 이 행도 주석입니다. 그러나 여러 행에 걸친 문자열 ''' ''' 또는 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;기호를 개행과 함께 사용해 여러 행 주석을 작성할 수도 있다.\n\u0026#34;\u0026#34;\u0026#34; 여기부터 주석으로 볼 수 있습니다. 이 행도 주석이라고 볼 수 있고, 원한다면 계속 주석을 작성할 수 있습니다. \u0026#34;\u0026#34;\u0026#34; 그러나 이는 여러 행에 걸쳐 문자열을 작성하는 방법으로, 정석적인 사용 방식은 아니다.\n9. 줄바꿈 코드를 작성하다보면 필요 이상으로 길어질 수도 있다.\n이러한 경우 백슬래시 \\를 사용해 코드를 여러 줄에 걸쳐 작성 가능하다.\nthis_is_test_variable = test \u0026lt; 0 or \\ real \u0026gt; 0 or \\ just_test == 1 리스트나 튜플, 딕셔너리의 요소를 구분하기 위한 개행은 백슬래시를 삽입하지 않아도 된다.\nweekdays = (\u0026#34;Mon\u0026#34;, \u0026#34;Tue\u0026#34;, \u0026#34;Wed\u0026#34;, \u0026#34;Thu\u0026#34;, \u0026#34;Fri\u0026#34;, \u0026#34;Sat\u0026#34;, \u0026#34;Sun\u0026#34;) 여기까지 데이터형과 데이터 구조를 정리해보았다.\n다음 챕터에서는 프로그래밍 언어의 꽃~~(개인적인 생각입니다)~~인 제어문에 대해 정리할 예정이다.\n(다음 글에서 계속됩니다.)\n","date":"2021-03-29T00:00:00Z","image":"https://everimind4.github.io/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-3/cover_hu0583afeab19a2de7dc49fcc1be6b44c7_761261_120x120_fill_box_smart1_2.png","permalink":"https://everimind4.github.io/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-3/","title":"데이터형과 데이터 구조 (3)"},{"content":"4. 데이터형 파이썬의 기본적인 데이터형은 다음과 같다.\n   종류 예약어 상세 예시     정수 int 소수점이 없음 4, 2, 6   실수 float 소수점이 있음 3.14, 2.71   문자열(String) str 문자열의 나열 'everimind4'   부울(Boolean) bool 논리값을 저장 True, False    1. 숫자 숫자를 저장하기 위한 변수는 다른 언어들과 마찬가지로 2종류가 있다.\n 정수형 : 정수 값을 저장, 소수점이 없다. 실수형 : 실수 값을 저장, 소수점이 있고, 부동소수형이라고도 한다.   C와의 차이점 : 예약어로 변수의 데이터형을 지정할 필요 없이 그냥 값을 저장하면 자동으로 지정된다.\n 그리고 다음과 같은 규칙이 있다.\n  같은 데이터형끼리 계산하면 기본적으로 같은 데이터형이 된다.\n  정수끼리 나눗셈을 하면 실수형이 된다.\n  정수와 실수형을 서로 계산하면 결과는 실수형이 된다.\n  2. 문자열  C와의 차이점 : 문자(char)형 변수는 없고 문자열(string)만 있다.\n 문자열은 ' ' 또는 \u0026quot; \u0026quot;로 감싸서 만든다.\n그 이유는, '나 \u0026quot;가 포함된 문자열을 저장하기 위해서이다.\n C에서는 \\' 또는 \\\u0026quot;와 같이 해당 기호 앞에 백슬래시(\\)를 적어 주는 방식으로 정규표현식을 사용해 이와 같은 문제를 해결하였다.\n Hi, my name is \u0026quot;Alan Choi\u0026quot;.\n위 문장을 저장하려면 어떻게 해야 할까? \u0026quot; \u0026quot;를 사용하면 is 까지만 저장하라는 의미가 되어 버릴 것이다. 이런 경우를 방지하기 위해 ' '와 \u0026quot; \u0026quot;의 2가지 형태를 지원한다.\n5. 형변환 데이터형은 서로 형변환이 가능하다.\n특정한 경우 변환 시 에러가 발생하는 것을 제외하면, 기본적으로 모든 자료형 간의 상호 변환이 가능하다.\n C와의 차이점 : C에서는 자체 문법으로 명시적(explicit) 혹은 묵시적(implicit) 방식으로 형변환을 했지만, 파이썬은 데이터형의 예약어를 이름으로 갖는 내장 함수를 사용해 형변환을 한다.\n 1. 정수로 변환 int(변환할 값)함수를 사용해 값을 변환한다.\n\u0026gt;\u0026gt;\u0026gt; int(4.26) 4 \u0026gt;\u0026gt;\u0026gt; int(\u0026#34;-4\u0026#34;) -4 \u0026gt;\u0026gt;\u0026gt; int(True) 1 \u0026gt;\u0026gt;\u0026gt; int(False) 0  실수형은 소숫점 이하를 버린다. True는 1, False는 0으로 변환된다. 문자열은 읽는 것처럼 변환해 준다.  무슨 말이냐 하면, 2번째 줄의 코드 int(\u0026quot;-4\u0026quot;)는 문자열을 정수로 변환한 것인데, 액면가(?) 그대로 인식해 사람이 읽는 것처럼 값으로 변환해 주는 것을 볼 수 있다.\n그렇다면 이런 코드를 실행하면 어떻게 될까?\n\u0026gt;\u0026gt;\u0026gt; int(\u0026#34;Hello, python!\u0026#34;) 다음과 같은 에러가 발생한다.\n\r문자열은 항상 정수로 변환될까?\r\n2. 실수로 변환 정수형과 마찬가지로, float(변환할 값) 함수를 사용해 값을 변환한다.\n\u0026gt;\u0026gt;\u0026gt; float(7) 7.0 \u0026gt;\u0026gt;\u0026gt; float(\u0026#34;-4.26\u0026#34;) -4.26 \u0026gt;\u0026gt;\u0026gt; float(True) 1.0 \u0026gt;\u0026gt;\u0026gt; float(False) 0.0 실수형과 크게 다르지 않은 결과를 보인다.\n 정수형은 소수점 이하를 .0으로 저장한다. True는 1.0, False는 0.0으로 변환된다. 문자열은 읽는 것처럼 변환해 준다.  그리고 (예상했겠지만) 다음과 같은 문자열 변환은 실수형과 마찬가지로 에러를 반환한다.\n\u0026gt;\u0026gt;\u0026gt; float(\u0026#34;Hello, python!\u0026#34;) \r실수형도 에러가 발생한다.\r\n3. 문자열로 변환 문자열로 변환하려면 str(변환할 값)함수를 사용한다.\n\u0026gt;\u0026gt;\u0026gt; str(4) \u0026#39;4\u0026#39; \u0026gt;\u0026gt;\u0026gt; str(-3.22) \u0026#39;-3.22\u0026#39; \u0026gt;\u0026gt;\u0026gt; str(True) \u0026#39;True\u0026#39; \u0026gt;\u0026gt;\u0026gt; str(False) \u0026#39;False\u0026#39; 변환 결과가 전부 ' '로 감싸진 문자열이다.\n4. 부울형으로 변환 부울형으로 변환하려면 bool(변환할 값)함수를 사용한다.\n\u0026gt;\u0026gt;\u0026gt; bool(4) True \u0026gt;\u0026gt;\u0026gt; bool(-3.22) True \u0026gt;\u0026gt;\u0026gt; bool(0) False \u0026gt;\u0026gt;\u0026gt; bool(0.0) False \u0026gt;\u0026gt;\u0026gt; bool(\u0026#34;Hello, python!\u0026#34;) True \u0026gt;\u0026gt;\u0026gt; bool(\u0026#39;\u0026#39;) False  0, 0.0, 빈 문자열은 False가 된다. 그 이외의 값은 전부 True가 된다.  6. 리스트, 튜플, 딕셔너리 파이썬을 제대로 사용하려면 반드시 이해하고 있어야 하는 핵심적인 자료형들이다.\n 리스트  0개 이상의 요소가 나열(Sequence)된 자료형 요소의 추가 및 삭제, 덮어쓰기가 가능(mutable)하다. 요소를 [ ]로 감싸서 만든다.   튜플  0개 이상의 요소가 나(Sequence)열된 자료형 한 번 만들어지고 나면 변경이 불가능하다(immutable). 요소를 ( )로 감싸서 만든다.   딕셔너리  키(Key)와 값(Value)의 쌍으로 이루어진 자료형 키(Key)는 인덱스(Index) 역할을 하며, 다른 키(Key)와 중복될 수 없다. 값(Value)은 키에 연결되며, 다른 값(Value)과 중복될 수 있다.     C와의 차이점\n리스트와 튜플은 C의 \u0026lsquo;배열(Array)\u0026lsquo;과 사용법이나 특징이 거의 동일하다. 리스트는 수정 가능한 배열, 튜플은 수정 불가능한 배열로 보아도 무방하다.\n 어차피 동일하다면, 값을 수정할 수 없는 튜플이 무슨 의미가 있는가? 라는 생각이 들 수도 있다.\n그러나 리스트에 비해 메모리를 적게 소비하고, 데이터를 실수로라도 변경할 수 없다는 점 등에서 차이가 난다.\n결국 적재적소에 잘 사용하는 것이 중요하다.\n1. 리스트 리스트는 0개 이상의 요소를 ,로 구분하여 [ ]를 사용해 선언한다.\n요소는 어떤 데이터형도 가능하다. 숫자, 문자, 부울뿐만 아니라 리스트, 튜플, 딕셔너리도 가능하다.\n\u0026gt;\u0026gt;\u0026gt; Months = [\u0026#34;January\u0026#34;, \u0026#34;February\u0026#34;, ..., \u0026#34;December\u0026#34;] \u0026gt;\u0026gt;\u0026gt; Friends = [\u0026#34;Alan\u0026#34;, \u0026#34;Crystal\u0026#34;, \u0026#34;Sally\u0026#34;] \u0026gt;\u0026gt;\u0026gt; Coffees = [\u0026#34;Americano\u0026#34;, \u0026#34;Espresso\u0026#34;, \u0026#34;Latte\u0026#34;, \u0026#34;Macchiato\u0026#34;, \u0026#34;Einspanner\u0026#34;] 특정 값을 참조하려면 리스트명 뒤에 [번호]를 붙이며, 값을 변경할 수도 있다.\n번호는 0부터 시작한다.\n\u0026gt;\u0026gt;\u0026gt; Months[2] \u0026#39;March\u0026#39; \u0026gt;\u0026gt;\u0026gt; Coffees[4] \u0026#39;Einspanner\u0026#39; \u0026gt;\u0026gt;\u0026gt; Friends [\u0026#39;Alan\u0026#39;, \u0026#39;Crystal\u0026#39;, \u0026#39;Sally\u0026#39;] append()메소드를 사용해 리스트 맨 끝에 요소를 추가할 수 있다.\n\u0026gt;\u0026gt;\u0026gt; Coffees.append(\u0026#34;Cappuccino\u0026#34;) \u0026gt;\u0026gt;\u0026gt; Coffees [\u0026#39;Americano\u0026#39;, \u0026#39;Espresso\u0026#39;, \u0026#39;Latte\u0026#39;, \u0026#39;Macchiato\u0026#39;, \u0026#39;Einspanner\u0026#39;, \u0026#39;Cappucchino\u0026#39;] insert()메소드를 사용해 지정한 위치에 요소를 추가할 수 있다.\n\u0026gt;\u0026gt;\u0026gt; Friends.insert(2, \u0026#34;No-Face\u0026#34;) \u0026gt;\u0026gt;\u0026gt; Friends [\u0026#39;Alan\u0026#39;, \u0026#39;Crystal\u0026#39;, \u0026#39;No-Face\u0026#39;, \u0026#39;Sally\u0026#39;] del 명령어를 사용해 리스트의 요소를 삭제할 수도 있다.\n\u0026gt;\u0026gt;\u0026gt; del Coffees[1] \u0026gt;\u0026gt;\u0026gt; Coffees [\u0026#39;Americano\u0026#39;, \u0026#39;Latte\u0026#39;, \u0026#39;Macchiato\u0026#39;, \u0026#39;Einspanner\u0026#39;, \u0026#39;Cappucchino\u0026#39;] del은 메소드가 아니라 파이썬 문법 내의 명령어이다. 따라서, Coffees.del(...)과 같은 방식으로 사용할 수 없다. 자세한 부분은 추후 클래스 챕터에서 다룬다.\n2. 튜플 튜플은 0개 이상의 요소를 ,로 구분하여 선언한다. ( )를 사용하지 않고도 선언 가능하지만, 튜플임을 명확히 나타내려면 ( )로 감싸 선언하는 편이 명확하다.\n보통 고정된 개수의 값을 포함하는 정보를 튜플에 묶어서 저장한다.\n본 교재의 목표는 게임 제작이다. 게임에서는 2차원상의 위치정보(x좌표, y좌표)를 저장할 필요가 있다.\n이와 같이 고정된 개수의 변수를 묶어서 저장하고 관리할 때는 튜플이 적합하다.\n\u0026gt;\u0026gt;\u0026gt; position = (40, 26) \u0026gt;\u0026gt;\u0026gt; position (40, 26) \u0026gt;\u0026gt;\u0026gt; position[0] 40 \u0026gt;\u0026gt;\u0026gt; position[1] 26 값을 변경할 수 없으므로 리스트의 append(), insert(), del등은 사용할 수 없다.\n튜플에는 독특한 사용법이 있다. 언팩(Unpack) : 하나의 튜플을 여러 변수에 대입하는 것\n\u0026gt;\u0026gt;\u0026gt; position = (40, 26) \u0026gt;\u0026gt;\u0026gt; position_x, position_y = position \u0026gt;\u0026gt;\u0026gt; position_x 40 \u0026gt;\u0026gt;\u0026gt; position_y 26 position이라는 이름의 튜플에 저장된 값이 position_x와 position_y에 나뉘어 저장된 것을 볼 수 있다.\n이를 응용하면 다음 작업도 가능하다.\n\u0026gt;\u0026gt;\u0026gt; x = 4 \u0026gt;\u0026gt;\u0026gt; y = 3 \u0026gt;\u0026gt;\u0026gt; (x, y) = (y, x) \u0026gt;\u0026gt;\u0026gt; x 3 \u0026gt;\u0026gt;\u0026gt; y 4 이는 마치 튜플의 값이 바뀐 것처럼 보이지만, 사실은 다음과 같은 과정을 거치게 된다.\n (y, x)가 3, 4으로 언팩된다. 새로운 튜플 (x, y)가 선언되고, 3, 4으로 초기화된다. x = 3, y = 4라는 값을 출력한다.  상기한 대로, 튜플의 값은 변화시킬 수 없다. 하지만 이는 튜플에 저장된 값을 수정하는 것이 아니라, 새로 선언된 튜플을 초기화하는 값으로 기존 튜플의 언팩을 사용한 것이다!\n3. 딕셔너리 말 그대로 사전처럼 쓸 수 있는 데이터 구조이다.\n리스트와 튜플에서는 숫자로 특정 값을 찾을 수 있었지만, 딕셔너리에서는 \u0026lsquo;키(Key)\u0026lsquo;로 \u0026lsquo;값(Value)\u0026lsquo;을 찾을 수 있다.\n선언 방법은 다음과 같다.\n\u0026gt;\u0026gt;\u0026gt; Profile = { \u0026#34;Name\u0026#34; = \u0026#34;Smith\u0026#34;, \u0026#34;Age\u0026#34; = 35, \u0026#34;Sex\u0026#34; = \u0026#34;M\u0026#34;, \u0026#34;Height\u0026#34; = 176, } \u0026gt;\u0026gt;\u0026gt; Profile {\u0026#39;Name\u0026#39;: \u0026#39;Smith\u0026#39;, \u0026#39;Age\u0026#39;: 35, \u0026#39;Sex\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;Height\u0026#39;: 176} \u0026gt;\u0026gt;\u0026gt; Profile[\u0026#34;Name\u0026#34;] \u0026#39;Smith\u0026#39; \u0026gt;\u0026gt;\u0026gt; Profile[\u0026#34;Age\u0026#34;] = 36 \u0026gt;\u0026gt;\u0026gt; Profile {\u0026#39;Name\u0026#39;: \u0026#39;Smith\u0026#39;, \u0026#39;Age\u0026#39;: 36, \u0026#39;Sex\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;Height\u0026#39;: 176} { }로 감싸고, (Key) : (Value)형태로 데이터를 작성한다. 키-값 쌍을 여러 개 저장하고 싶으면 ,로 구분한다.\n키와 값은 임의의 데이터형을 모두 사용할 수 있지만 일반적으로 키에는 문자열을 사용한다.\n딕셔너리의 요소를 참조하고자 할 때는 리스트/튜플과는 다르게 [] 내에 번호가 아닌 키 값을 지정한다.\n지금까지의 내용을 정리하면 다음과 같다.\n    리스트 튜플 사전     선언법 [ ] ( ) { }   데이터 구조 나열(Sequence) 나열(Sequence) K-V 쌍 (Dictionary)   참조 방식 변수명[번호] 변수명[번호] 변수명[키]   특징 수정 가능함 수정 불가함 순서가 없음    4. 다차원 리스트(튜플) 앞서 한 번 언급한 적 있지만, 리스트나 튜플은 또 다른 리스트나 튜플을 원소로 가질 수도 있다.\n C에서도 배열을 비슷한 방식으로 사용할 수 있다.\n배열의 원소가 배열인 경우를 2차원 배열이라고 부른다.\n 또한, 튜플의 원소가 리스트이거나, 리스트의 원소가 튜플일 수도 있다.\n이런 사용 방식에는 다음과 같은 특징이 따라오게 된다.\n 리스트의 원소가 튜플인 경우 해당 튜플이 쉽게 다른 것으로 대체될 수 있다. 튜플의 원소가 리스트인 경우 해당 리스트의 값을 수정할 수 있다.  각 자료형을 사용하는 이점이 흐려지는 느낌이 들기 때문에, 내 생각에는 이런 형태는 지양하는 편이 나을 듯 하다.\n마지막으로 예시를 하나만 살펴보자.\n학생 3명의 이름을 저장한 튜플, 학생 3명의 개인 성적을 저장한 튜플이 있다고 하자. 이 2개의 튜플을 요소로 갖는 또 다른 튜플을 다음과 같이 선언할 수 있다.\n\u0026gt;\u0026gt;\u0026gt; name = (\u0026#34;Alan\u0026#34;, \u0026#34;Crystal\u0026#34;, \u0026#34;Sally\u0026#34;) \u0026gt;\u0026gt;\u0026gt; score = (85, 97, 90) \u0026gt;\u0026gt;\u0026gt; data = (name, score) \u0026gt;\u0026gt;\u0026gt; data ((\u0026#39;Alan\u0026#39;, \u0026#39;Crystal\u0026#39;, \u0026#39;Sally\u0026#39;), (85, 97, 90)) 3번째 학생인 'Sally'의 성적은 score[2]로도 조회가 가능하지만, data[0][2]로도 조회할 수 있다. data[0]에 저장된 요소가 score이기 때문이다!\n위의 예시에서는 각각 튜플을 미리 선언한 후, 해당 튜플의 이름을 새로운 튜플의 요소로 넣었지만 전체를 직접 작성하는 것도 가능하다.\n\u0026gt;\u0026gt;\u0026gt; data = ((\u0026#34;Alan\u0026#34;, \u0026#34;Crystal\u0026#34;, \u0026#34;Sally\u0026#34;), (85, 97, 90)) \u0026gt;\u0026gt;\u0026gt; data ((\u0026#39;Alan\u0026#39;, \u0026#39;Crystal\u0026#39;, \u0026#39;Sally\u0026#39;), (85, 97, 90)) 그리고 책에는 추가적인 예시로 틱택토 게임을 리스트의 리스트를 사용해 나타낼 수 있는 방법에 대해서도 소개하고 있었는데, 해당 부분은 생략하기로 한다.\n원래 이번 글에 챕터의 모든 내용을 정리하려 했으나 생각보다 길어지는 관계로, 리스트 및 튜플에 관련된 함수들은 다음 포스팅에서 다루기로 한다.\n(다음 글에서 계속됩니다.)\n","date":"2021-03-22T00:00:00Z","image":"https://everimind4.github.io/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-2/cover_hu0583afeab19a2de7dc49fcc1be6b44c7_761261_120x120_fill_box_smart1_2.png","permalink":"https://everimind4.github.io/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-2/","title":"데이터형과 데이터 구조 (2)"},{"content":"1. 연산 1.1 기본 연산자 코딩을 조금이라도 공부해 본 사람은 알겠지만, 파이썬에서는 여타 수많은 프로그래밍 언어와 마찬가지로 다양한 연산자를 지원하고 있다.\n    수학에서의 기호 파이썬에서의 기호     덧셈 + +   뺄셈 - -   곱셈 × *   나눗셈 ÷ /     주의할 점은, 자료형(정수형, 실수형, \u0026hellip;)에 따라 계산 방식이 조금씩 다를 수 있다는 것이다.  또, Python IDLE Shell에서는 파이썬 코드를 입력하면 실행 결과가 바로 출력되는 것을 볼 수 있다.\n\rPython IDLE Shell :: 사칙연산\r\n그리고 맨 아래 계산 (4 * 2) / 6을 보면 알 수 있겠지만, 일반적인 수학적 표현에서와 마찬가지로 괄호( )를 이용해 계산의 우선순위를 지정할 수 있다.\n사칙연산 이외에도 여러 가지 연산자를 사용할 수 있다.\n   연산자 종류 기호     나눗셈의 나머지 구하기 %   나눗셈의 몫 구하기 //   지수(거듭제곱) 구하기 **    \rPython IDLE Shell :: 몫/나머지, 지수 계산\r\n 일반적인 나눗셈이 아닌 정수 나눗셈의 경우 몫과 나머지를 각각 %, // 연산자를 사용하여 계산한다. 파이썬에서는 거듭제곱을 계산할 때 ** 연산자를 사용하여 (밑) ** (지수) 형태로 나타낸다.  몫과 나머지를 한 번에 구하는 divmod() 함수도 있다.\n\u0026gt;\u0026gt;\u0026gt; divmod(26, 4) (6, 2) 2. 변수 프로그래밍에서 변수는 값을 저장하고, 저장된 값을 변경할 수 있다는 특징이 있다.\n파이썬의 변수 사용법도 다른 언어와 크게 다르지 않다.\n\u0026gt;\u0026gt;\u0026gt; a = 4 \u0026gt;\u0026gt;\u0026gt; b = 2 \u0026gt;\u0026gt;\u0026gt; a + b 6 \u0026gt;\u0026gt;\u0026gt; a * b 8 \u0026gt;\u0026gt;\u0026gt; a / b 2.0 다른 언어들과 마찬가지로 변수명을 정할 때는 몇 가지 규칙이 있다.\n  알파벳 대소문자, 숫자, 언더바(_)만 사용할 수 있다.\n  숫자는 맨 앞에 올 수 없다.\n  예약어(reserved word)는 변수명이 될 수 없다.\nex. if for return . . .\n  위 예시를 보면 알 수 있듯, 예약어는 특정 프로그래밍 언어 문법에서 이미 용도가 지정된 단어를 말한다.\n그리고 이쯤에서 한 마디 덧붙이자면, 책을 그대로 옮기는 듯한, 그러니까 일종의 아카이빙을 하는 느낌이 들기 시작했다.\n그래서 지금부터는 새롭게 배우게 된 내용을 정리하고, 이미 알고 있는 내용은 간단하게 요약하고 넘어가는 식으로 공부하기로 했다. 다른 프로그래밍 언어를 배우는 과정에서 이미 학습한 내용을 굳이 또 정리할 필요는 없기도 하고, 무엇보다도 현재 방식대로 진행하면 진도가 너무 느리다. 어쨌든 이제부터는 빠르게 진행해보기로 결정!\n3. 함수 지금까지 여러 연산자들을 살펴보았다.\n지금 살펴보는 함수는 이런 연산자들과 또 다른 함수들을 결합하여 특정 기능을 수행하도록 만든 것이다.\n다른 언어들과 마찬가지로, 파이썬의 함수도 함수명 뒤에 괄호 ( )를 붙여 실행한다.\n 함수명(인수1, 인수2, \u0026hellip; )  인수 : 함수에 전달되는 값 반환값 : 함수로부터 돌아오는 값    예를 들어 각각 인수 2개를 입력받아, 인수 2개를 더한 결과를 반환하는 sum이라는 함수와, 인수 2개 중 더 큰 값을 반환하는 max라는 함수가 있다고 하자. 그러면 다음과 같은 결과를 볼 수 있다.\n\u0026gt;\u0026gt;\u0026gt; sum(3, 5) 8 \u0026gt;\u0026gt;\u0026gt; max(4, 2) 4 max는 파이썬에 내장되어 있는 함수이고, sum은 + 연산자의 기능을 함수로 만든 것인데, 이런식으로 함수를 직접 만드는 방법은 아마 나중에 함수 파트에서 자세히 배우지 않을까 싶다.\n그리고 파이썬은 객체지향 언어이다. 즉, 객체에 딸린 함수들이 존재하고, **메소드(Method)**라고 부른다.\n일반적인 함수와 메소드의 차이는 다음과 같다.\n 함수 : 함수의 이름만 써서 원할 때 호출할 수 있다. 메소드 : 객체와 메소드 명을 모두 써야 하고, 객체가 존재해야만 호출할 수 있다.  이 부분도 마찬가지로 자세한 내용은 추후 객체 파트가 나온다면 학습하지 않을까 싶다.\n(다음 글에서 계속됩니다.)\n","date":"2021-03-15T00:00:00Z","image":"https://everimind4.github.io/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-1/cover_hu0583afeab19a2de7dc49fcc1be6b44c7_761261_120x120_fill_box_smart1_2.png","permalink":"https://everimind4.github.io/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-1/","title":"데이터형과 데이터 구조 (1)"},{"content":"교재 소개  파이썬을 공부하고자 좋은 교재가 없는지 찾아보다, 기초 문법도 학습할 수 있고 개인 프로젝트도 직접 만들어 볼 수 있는 교재를 발견하였다. 바로 게임으로 배우는 파이썬!   본 교재는 1부와 2부로 구성되어 있다.  1부에서는 파이썬의 기초 문법에 대해 학습 2부에서는 학습한 내용을 기초로 하여 직접 고전 게임을 만들어보는 프로젝트를 진행   따라서 해당 교재를 공부한 내용과 프로젝트를 수행한 결과물을 본 블로그 및 Github Repository에 업로드 할 예정이다!  1. 파이썬(Python) 소개 1.1 라이브러리 파이썬은 문법이 간단해 배우기 쉽지만, 그것만으로는 할 수 있는 일이 제한적이다.\n따라서 목적에 맞는 라이브러리를 로드해 사용한다.\n대표적인 라이브러리의 종류는 다음과 같다.\n NumPy : 수치 계산 SciPy : 과학 기술 계산 PIL : 영상처리 Tkinter : GUI(그래픽 유저 인터페이스) Beautiful Soup : HTML 정보 수집(스크래핑) PyGame : 게임 제작 파일을 읽고 쓰거나 네트워크 작업에 관련된 라이브러리 등의 표준 라이브러리 기타 수많은 3rd Party 라이브러리  이처럼 다양한 라이브러리들이 많은데, 이 책은 게임을 만드는 것을 목표로 하고 있으므로 PyGame은 무조건 사용할 것 같고, 나중에 다른 라이브러리도 사용하게 될 지 모를 일이다.\n1.2 설치  Python 3 설치 : Windows 사용자는 아나콘다 혹은 파이썬을 설치할 것 (현재 최신 버전 : 3.9.2) PyGame 라이브러리 다운로드  나는 아나콘다를 제외하고 파이썬만 여기서 다운받아 설치하였다.\n설치 완료 후 명령 프롬프트를 열어 pip install pygame 명령어를 입력한다.\n마찬가지로 설치가 완료되면, 파이썬을 실행해 import pygame 명령어로 설치 여부를 확인한다.\n\r이런 메시지가 출력되면 성공(인 것 같다)\r\nMacOS 설치 방법은 생략하도록 하겠다(찾아보면 금방 나오고 별로 다르지도 않다).\n다음 글에서는 Python의 자료형과 자료구조에 대해 학습할 예정이다.\n","date":"2021-03-10T00:00:00Z","image":"https://everimind4.github.io/p/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/cover_hu0583afeab19a2de7dc49fcc1be6b44c7_761261_120x120_fill_box_smart1_2.png","permalink":"https://everimind4.github.io/p/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/","title":"시작하기"},{"content":"1. Github 블로그  \u0026quot; 개발자라면 Github 블로그 하나 정도는 있어야지! \u0026quot;\n 라는 말을 어디선가 주워듣고 Github로 블로그를 만들어보자, 결심하게 되었다.\n그런데 생각보다 진입장벽이 낮지는 않았고, 익숙해지는 데 생각보다 시간이 걸린 데다 시행착오도 제법 겪으며 결국 어찌저찌 성공은 하였다(그 결과물을 지금 보고 계십니다).\n그래서 관련 내용을 정리해서 포스팅하면 Hugo로 블로그를 만들어 Github로 호스팅하고자 하는 사람들이 조금이나마 도움을 받을 수 있을 듯 하여, 첫 포스팅 주제는 블로그를 만드는 방법으로 결정!\n2. 준비물 각 항목 클릭 시 해당 설치 파일을 받을 수 있는 웹사이트로 링크 (OS에 맞는 최신 버전을 다운로드)\n Git Hugo  Hugo theme (마음에 드는 테마 하나 선택)   Typora (Markdown 에디터)  3. 설치하기 3.1. Git 설치  Hugo blog만 사용하고자 하는 경우 설치 옵션 그대로 유지 명령 프롬프트에 git version를 입력하여 잘 설치되었는지 확인  3.2. Github Repository 2개 만들기  '(Username).github.io' : 빌드 결과인 블로그 HTML 파일을 저장하는 Public Repository, 이름 양식 필히 준수 (everimind4.github.io)   Hugo blog 전체 파일을 관리하는 Private Repository, 이름 자유롭게 설정 (필자의 경우 blog로 설정)  3.3. 로컬 디렉토리 생성 및 구성   C:\\Hugo\\bin 디렉토리 생성 후 다운로드한 Hugo Zip 파일 압축 해제\n  Windows + Q ▶ 시스템 환경 변수 편집 ▶ PATH에 C:\\Hugo\\bin 추가\n  Git Bash 실행 후 C:\\Hugo 위치에서 $ hugo new site blog 명령으로 로컬 컨텐츠 디렉토리 생성\n C:\\Hugo\\blog에서 dir 명령으로 디렉토리 구조를 확인 가능 이후, Git Bash 속성에서 시작 위치를 C:\\Hugo\\blog로 설정하면 작업이 편해집니다!    3.4. 테마 다운로드 및 설정  2번에서 고른 테마의 github 저장소 주소를 복사 ~\\blog 경로에서 $ git init 명령 실행 후 $ git submodule add (복사한 주소) themes\\(테마 이름) 명령으로 테마를 submodule로 추가 config.toml 파일의 내용을 각 테마 Github 페이지의 예시 파일을 보면서 수정  toml이 아닌 yml/yaml 파일만 존재하는 경우 YAML to TOML converter 등을 사용    3.5. Github 원격 저장소와 로컬 디렉토리 연결  Github에 만든 blog 저장소(본인이 설정한 이름)와 C:\\Hugo\\blog 디렉토리 연결  C:\\Hugo\\blog로 이동 $ git init $ git remote add origin https://github.com/everimind4/blog.git   everimind4.github.io 저장소를 blog의 submodule로 등록  $ git submodule add -b main https://github.com/everimind4/everimind4.github.io.git public    3.6. 컨텐츠 생성  $ hugo new post/test.md 명령을 실행하면 blog\\content\\post\\ 위치에 test.md 파일이 생성됨 Typora 등의 Markdown Editor를 사용하여 md 파일 내용 작성 (자세한 방법을 다음 글에서 다룸) $ hugo server 또는 hugo server -D 명령어로 웹서버 실행  http://localhost:1313/에 접속해서 확인 md 파일의 Draft 옵션이 true로 설정된 경우 빌드에서 제외됨 -D 옵션은 md파일의 Draft 문서들도 확인 가능한 옵션 (다른 옵션은 여기서 확인)    3.7. 컨텐츠 업로드  C:\\Hugo\\blog로 이동 $ hugo -t (테마이름) 명령으로 테마가 적용된 블로그 내용을 ~\\public에 생성 $ cd public public 디렉토리로 이동 $ git add . 수정된 파일 내역 저장 $ git commit -m \u0026quot;(description)\u0026quot; 변경 내용 commit $ git push origin main everimind4.github.io에 커밋 내용 Push blog 저장소에도 변경 내용 Push  $ cd .. public의 한 단계 상위 디렉토리인 blog로 이동 $ git add . $ git commit -m \u0026quot;(description)\u0026quot; $ git push origin main    4. 마무리하며 여기까지 따라왔다면 블로그에 글을 작성하고 빌드하여 블로그의 기초를 다지는 방법은 모두 배우셨습니다.\n이어지는 글들을 통해 아래 내용들을 다룰 예정입니다.\n 블로그 세부 설정  config.toml 파일의 세부 내용을 수정하기 Disquss 등의 댓글 위젯 추가하기 Google Analytics 연동하기 sitemap.xml을 추가해 검색 엔진에 노출시키기   마크다운 에디터 Typora를 사용해 글쓰기  글 작성 Tips 기본적인 문법 및 단축키    ","date":"2021-02-20T00:00:00Z","permalink":"https://everimind4.github.io/p/%ED%9C%B4%EA%B3%A0hugo%EB%A1%9C-github-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-1/","title":"휴고(Hugo)로 Github 블로그 만들기 (1)"}]